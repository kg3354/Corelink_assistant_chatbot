file,chunk_id,chunk,source_url
scraped_data/corelink.hsrn.nyu.edu/documentation_technical-overview.html,0,"We are in the process of updating these pages. Please refer to the new Corelink Documentation at https://corelink-docs.hsrn.nyu.edu Control Stream example with sender logging in first Control Stream example with receiver logging in first Control messages and data packets into separate streams. 5 stream types are available: TCP control stream that uses JSON messages to communicate WS control stream that uses JSON messages to communicate TCP stream for data UDP stream for data WS stream for data The workflow to use the streams: Login (user must be available in the user database, we might expand in the future to LDAP, oAuth2 etc. For now the standard user is Testuser with Testpassword. The login allows users to: A user can log in several times and use different tokens Tokens expire after a timeout Get available rooms: for now the room ‘Holodeck’ will be always available Register stream in available room List available streams Subscribe to available stream",https://corelink.hsrn.nyu.edu/documentation/technical-overview
scraped_data/corelink.hsrn.nyu.edu/next-steps.html,0,Home Examples Documentation Technical Overview Client Documentation Server Documentations Client Initiated Control Functions Server Initiated Control Functions Corelink Plugins Protocol Documentation Control Stream Protocol Data Stream Protocol Next Steps Get Started Contributing to Corelink Naming Convention Guidelines About Us Team Collaborators Support Contact Us Get Started Download : Get Corelink Corelink - Real Time Networking for Research. Home Examples Documentation Technical Overview Client Documentation Server Documentations Client Initiated Control Functions Server Initiated Control Functions Corelink Plugins Protocol Documentation Control Stream Protocol Data Stream Protocol Next Steps Get Started Contributing to Corelink Naming Convention Guidelines About Us Team Collaborators Support Contact Us,https://corelink.hsrn.nyu.edu/next-steps
scraped_data/corelink.hsrn.nyu.edu/documentation.html,0,"We are in the process of updating these pages. Please refer to the new Corelink Documentation at https://corelink-docs.hsrn.nyu.edu Control Stream example with sender logging in first Control Stream example with receiver logging in first Control messages and data packets into separate streams. 5 stream types are available: TCP control stream that uses JSON messages to communicate WS control stream that uses JSON messages to communicate TCP stream for data UDP stream for data WS stream for data The workflow to use the streams: Login (user must be available in the user database, we might expand in the future to LDAP, oAuth2 etc. For now the standard user is Testuser with Testpassword. The login allows users to: A user can log in several times and use different tokens Tokens expire after a timeout Get available rooms: for now the room ‘Holodeck’ will be always available Register stream in available room List available streams Subscribe to available stream",https://corelink.hsrn.nyu.edu/documentation
scraped_data/corelink.hsrn.nyu.edu/index.html,0,"Corelink is a real time low latency network framework that facilitates connecting users, data, and applications with computational resources. Corelink software is open source and licensed under the MIT license. The Corelink distributed stream management platform allows users to define, send and receive real-time data in virtually any format - audio, motion capture, video, floorplans, maps, facial capture, virtual reality tracking, and many more. We are in the process of updating these pages. Please refer to the new Corelink Documentation at https://corelink-docs.hsrn.nyu.edu Audio through Corelink to audio and text. Motion tracking point cloud through Corelink to VR rendering of skeleton. Multiple users shared data through Corelink. Corelink is designed to provide low latency cross platform stream processing. Computers can connect to Corelink to send and receive streams via web application or command line script, or via a VR headset, or GUI software interface.",https://corelink.hsrn.nyu.edu/index
scraped_data/corelink.hsrn.nyu.edu/index.html,1,"Corelink uses a very small fixed header (8 bytes) to minimize data transfer latencies , with development capacity to add a flexible header for specific applications loads. Though servers inherently add a certain amount of latency overhead to the run time on the fiber, tests show a current NYU network latency below 5ms (depending on packet size and functional overhead on the server). The Corelink protocol defines a federated model that shares user and workspace information across many locations, permitting the system to minimize stream transport latencies locally (in the same network or city) and globally (across longer distances). Corelink manages all the routing needed to create a pipeline, a broadcast, a multicast, or any other web of connection possibilities. Corelink also incorporates a user and workspace management capability to restrict streams to specific applications, functions or users. Custom plugins help the user to process streams in real-time.",https://corelink.hsrn.nyu.edu/index
scraped_data/corelink.hsrn.nyu.edu/index.html,2,"Examples include video transcoders, audio spatialization functions, data encoding but users can create their own plugins and processing pipelines. Corelink has developed client libraries that simplify developing and integrating real time applications including: NodeJS, Browser, C++, C#. A dynamically linked C++ library allows other languages, like Python, to use the Corelink bindings to enable high speed low latency data transfers. Under the hood, Corelink uses user authentication, a publish-subscribe model, and selective data transmission to get data from point A to point B, C, D, etc. The authentication and control messages are secured and encrypted through websockets-secure, while the data can be sent using UDP, TCP, and websockets-secure depending on the users or applications needs (fastest option, no loss, encrypted, etc.). As each packet reaches the server, the server can route that packet to any user who has requested and has permission to access the data.",https://corelink.hsrn.nyu.edu/index
scraped_data/corelink.hsrn.nyu.edu/index.html,3,"Corelink was initially developed as a transport layer for the NYU-Holodeck project with funding from the National Science Foundation (NSF MRI award. #1626098) The Corelink team continues to work on future functionality, and adding features like asset management, a web-based admin interface to manage the server, fine grained permissions and enhanced configuration management for users and applications.!",https://corelink.hsrn.nyu.edu/index
scraped_data/corelink.hsrn.nyu.edu/documentation_server-documentation_client-initiated-control-functions.html,0,Client Initiated Control Functions auth authenticate a user Request: Response: keepAlive ping the server to keep alive Request: Response: listFunctions list available client functions Request: Response: listServerFunctions list available server functions Request: Response: describeFunction retrieve client initiated function description Request: Response: describeServerFunction retrieve description of server initiated function Request: Response: listWorkspaces list existing workspaces Request: Response: addWorkspace add a new workspace Request: Response: setDefaultWorkspace set a default workspace Request: Response: getDefaultWorkspace get a default workspace Request: Response: rmWorkspace remove an existing workspace Request: Response: addUser add a new User Request: Response: password change password for an existing User Request: Response: rmUser remove an existing User Request: Response: listUsers list existing users Request: Response: addGroup add a new Group Request: Response: addUserGroup add a user to a Group Request: Response: rmUserGroup remove a user to a Group Request: Response: changeOwner change an existing Group ownership Request: Response: rmGroup remove an existing Group Request: Response: listGroups list existing Group Request: Response: sender register a new stream as sender Request: Response: listStreams list existing stream Request: Response: streamInfo get information about a stream Request: Response: receiver register a new stream as receiver Request: Response: subscribe subscribe additional streams to an existing receiver Request: Response: unsubscribe unsubscribe streams from an existing receiver Request: Response: setConfig set a server config Request: Response: disconnect disconnect a stream or several streams for the logged in user Request: Response: expire expire a user session Request: Response:,https://corelink.hsrn.nyu.edu/documentation/server-documentation/client-initiated-control-functions
scraped_data/corelink.hsrn.nyu.edu/documentation_client-documentation.html,0,Home Examples Documentation Technical Overview Client Documentation Server Documentations Client Initiated Control Functions Server Initiated Control Functions Corelink Plugins Protocol Documentation Control Stream Protocol Data Stream Protocol Next Steps Get Started Contributing to Corelink Naming Convention Guidelines About Us Team Collaborators Support Contact Us Client Documentation NodeJS C++ C# Python Corelink - Real Time Networking for Research. Home Examples Documentation Technical Overview Client Documentation Server Documentations Client Initiated Control Functions Server Initiated Control Functions Corelink Plugins Protocol Documentation Control Stream Protocol Data Stream Protocol Next Steps Get Started Contributing to Corelink Naming Convention Guidelines About Us Team Collaborators Support Contact Us,https://corelink.hsrn.nyu.edu/documentation/client-documentation
scraped_data/corelink.hsrn.nyu.edu/next-steps_contributing-to-corelink.html,0,"First off, thanks for taking the time to contribute! The following is a set of guidelines for contributing to Holodeck and its packages.These are mostly guidelines, not rules. Use your best judgment, and feel free to propose changes to this document in a pull request. All JavaScript code must adhere to Airbnb JavaScript Style Guide For consistency in our code style and formatting,tools like ESLint,Prettier,Husky and Lint-staged are used. ESLint is a tool which checks that our code conforms to our defined ""rules"" about coding convention and style.Prettier is a formatting tool that will format our code in a consistent way every time we run the tool. Lint-staged is a tool that allows us to run linters and other such tools against only the files that are currently staged on git (ie the files we have “git added”).Husky is a tool that allows us specify certain scripts to run as git hooks in our package.json file.",https://corelink.hsrn.nyu.edu/next-steps/contributing-to-corelink
scraped_data/corelink.hsrn.nyu.edu/next-steps_contributing-to-corelink.html,1,"Husky takes care of actually setting up the hooks and running our scripts, we just tell it when to run and what to run. We will use lint-staged to run eslint, prettier and run our jest tests against the files that have been staged. Lint staged will be triggered to run by husky as a pre commit. Lint-staged will run eslint and prettier against the files that have been staged. Lint staged will be triggered to run by husky as a pre commit hook. So the workflow looks like this:",https://corelink.hsrn.nyu.edu/next-steps/contributing-to-corelink
scraped_data/corelink.hsrn.nyu.edu/documentation_server-documentation.html,0,Client Initiated Control Functions auth authenticate a user Request: Response: keepAlive ping the server to keep alive Request: Response: listFunctions list available client functions Request: Response: listServerFunctions list available server functions Request: Response: describeFunction retrieve client initiated function description Request: Response: describeServerFunction retrieve description of server initiated function Request: Response: listWorkspaces list existing workspaces Request: Response: addWorkspace add a new workspace Request: Response: setDefaultWorkspace set a default workspace Request: Response: getDefaultWorkspace get a default workspace Request: Response: rmWorkspace remove an existing workspace Request: Response: addUser add a new User Request: Response: password change password for an existing User Request: Response: rmUser remove an existing User Request: Response: listUsers list existing users Request: Response: addGroup add a new Group Request: Response: addUserGroup add a user to a Group Request: Response: rmUserGroup remove a user to a Group Request: Response: changeOwner change an existing Group ownership Request: Response: rmGroup remove an existing Group Request: Response: listGroups list existing Group Request: Response: sender register a new stream as sender Request: Response: listStreams list existing stream Request: Response: streamInfo get information about a stream Request: Response: receiver register a new stream as receiver Request: Response: subscribe subscribe additional streams to an existing receiver Request: Response: unsubscribe unsubscribe streams from an existing receiver Request: Response: setConfig set a server config Request: Response: disconnect disconnect a stream or several streams for the logged in user Request: Response: expire expire a user session Request: Response:,https://corelink.hsrn.nyu.edu/documentation/server-documentation
scraped_data/corelink.hsrn.nyu.edu/about-us_support.html,0,Corelink is an open source network communication infrastructure that has been developed with support from New York University and NSF research funding (including: Award #1626098 MRI: Development of Experiential Supercomputing: Developing a Transdisciplinary Research and Innovation Holodeck),https://corelink.hsrn.nyu.edu/about-us/support
scraped_data/corelink.hsrn.nyu.edu/next-steps_get-started.html,0,Home Examples Documentation Technical Overview Client Documentation Server Documentations Client Initiated Control Functions Server Initiated Control Functions Corelink Plugins Protocol Documentation Control Stream Protocol Data Stream Protocol Next Steps Get Started Contributing to Corelink Naming Convention Guidelines About Us Team Collaborators Support Contact Us Get Started Download : Get Corelink Corelink - Real Time Networking for Research. Home Examples Documentation Technical Overview Client Documentation Server Documentations Client Initiated Control Functions Server Initiated Control Functions Corelink Plugins Protocol Documentation Control Stream Protocol Data Stream Protocol Next Steps Get Started Contributing to Corelink Naming Convention Guidelines About Us Team Collaborators Support Contact Us,https://corelink.hsrn.nyu.edu/next-steps/get-started
scraped_data/corelink.hsrn.nyu.edu/documentation_server-documentation_server-initiated-control-functions.html,0,Server Initiated Control Functions update update a receiver with a new stream from sender Request: subscriber Update a sender with a new stream that subscribed. Request: stale Update a receiver that stream is stale and not in use anymore. A sender might have dropped or the stream might have timed out. Request: dropped Update a sender that receivers have dropped or unsubscribed. Request:,https://corelink.hsrn.nyu.edu/documentation/server-documentation/server-initiated-control-functions
scraped_data/corelink.hsrn.nyu.edu/documentation_plugins.html,0,Plugins are a method to add on the fly scalable processing to streams. Corelink - Real Time Networking for Research.,https://corelink.hsrn.nyu.edu/documentation/plugins
scraped_data/corelink.hsrn.nyu.edu/documentation_protocol-documentation.html,0,"The control stream protocol allows the clients and the server to exchange control information to setup the data streams. The protocol is based on basic JSON strings that get exchanged. When to contol port is connected the client has to authenticate to get a token. With this token client intitated functions can be submitted to the server. The server has also the option to initiate communication with the client to update the client about changes in contol functionality or to initiate a disconnect. The control stream can me used in two different protocol types The TCP control stream is not encrypted at the moment, but could be in future versions. However, the websocket secure (WSS) control stream is encrypted and is the prefered method to connect to the server. When the client wants to connect to the server or manage streams it can start the communication with the server.",https://corelink.hsrn.nyu.edu/documentation/protocol-documentation
scraped_data/corelink.hsrn.nyu.edu/documentation_protocol-documentation.html,1,"All client initiated communication the control channel has the following basic data format: { ""ID"": number, - the ID is a tag that the server echos back to the client. In this way the client knwos which request and answer is for ""function""(string):""functionname"", - identify a function to run ""parameter1*"":"""", - parameters of the function ""parameter2*"":"""", parameter names and types can be ""parameterN*"":"""" freely selected for each function } { ""ID"": number, - the ID that was supplied in the request ""response1*"":"""", - response of the function ""response2*"":"""", response names and types can be ""response""*:"""", freely selected for each function ""statuscode""(integer):XXX, - status code of the function ""message""*:"""" - optional status description } Functions cannot return a reponse with a variable 'function', since it is reserved for server initiated functions. The server can initiate functions on the control channel (rather than the client initiating them).",https://corelink.hsrn.nyu.edu/documentation/protocol-documentation
scraped_data/corelink.hsrn.nyu.edu/documentation_protocol-documentation.html,2,"All modules that communicate on the control channel will have the following basic data format: { ""function""(string):""functionname"", - identify a function to run ""parameter1*"":"""", - parameters of the function ""parameter2*"":"""", parameter names and types can be ""parameterN*"":"""" freely selected for each function } { ""response1*"":"""", - response of the function ""response2*"":"""", response names and types can be ""response""*:"""", freely selected for each function ""statuscode""(integer):XXX, - status code of the function ""message""*:"""" - optional status description }",https://corelink.hsrn.nyu.edu/documentation/protocol-documentation
scraped_data/corelink.hsrn.nyu.edu/documentation_protocol-documentation_data-stream-protocol.html,0,"After the control connection is established, streams can be instatiated in three different kinds of protocols: If one client sends a stream in one protocol and another client receives the stream in a different protocol the server will automatically convert between the protocols. The packets that are sent can have a variable length. The first 6 bytes are contain the packet size information. The first 2 bytes denote the header length as an integer starting after the 6th byte. The next 4 bytes denote the data length starting after the header. The header is a Json string with packet based header information. At the moment only a stream id and a millisecond unix timestamp of synchronized time is submitted. The data itself is treated as a binary blob and can have any format. With the 6 header bytes future adaptation of the header can be achieved. We recommend that the data package is not larger than a few KB if the transfer is time sensitive. The TCP data stream is not encrypted.",https://corelink.hsrn.nyu.edu/documentation/protocol-documentation/data-stream-protocol
scraped_data/corelink.hsrn.nyu.edu/documentation_protocol-documentation_data-stream-protocol.html,1,"If encryption is desired, WSS streams are available. ID - the stream ID for the packet time - the client time stamp for the packet Valid keys in the optional json header are: stamp - a key that will make the server put its time stamp and return the packet to its source packet - if the client has to cut a packet into several small blocks it will have to send a packet x/y where x is the current packet number and y is the total packet count limit:[streamIDs] (limits the paket destination to a set of streamids)",https://corelink.hsrn.nyu.edu/documentation/protocol-documentation/data-stream-protocol
scraped_data/corelink.hsrn.nyu.edu/about-us_contact-us.html,0,Please feel free to contact us with any questions or comments about the code and documentation. You are welcome to add your own questions by making a new corelink tag on stackoverflow and our team will help find you an answer. Corelink - Real Time Networking for Research.,https://corelink.hsrn.nyu.edu/about-us/contact-us
scraped_data/corelink.hsrn.nyu.edu/documentation_protocol-documentation_control-stream-protocol.html,0,"The control stream protocol allows the clients and the server to exchange control information to setup the data streams. The protocol is based on basic JSON strings that get exchanged. When to contol port is connected the client has to authenticate to get a token. With this token client intitated functions can be submitted to the server. The server has also the option to initiate communication with the client to update the client about changes in contol functionality or to initiate a disconnect. The control stream can me used in two different protocol types The TCP control stream is not encrypted at the moment, but could be in future versions. However, the websocket secure (WSS) control stream is encrypted and is the prefered method to connect to the server. When the client wants to connect to the server or manage streams it can start the communication with the server.",https://corelink.hsrn.nyu.edu/documentation/protocol-documentation/control-stream-protocol
scraped_data/corelink.hsrn.nyu.edu/documentation_protocol-documentation_control-stream-protocol.html,1,"All client initiated communication the control channel has the following basic data format: { ""ID"": number, - the ID is a tag that the server echos back to the client. In this way the client knwos which request and answer is for ""function""(string):""functionname"", - identify a function to run ""parameter1*"":"""", - parameters of the function ""parameter2*"":"""", parameter names and types can be ""parameterN*"":"""" freely selected for each function } { ""ID"": number, - the ID that was supplied in the request ""response1*"":"""", - response of the function ""response2*"":"""", response names and types can be ""response""*:"""", freely selected for each function ""statuscode""(integer):XXX, - status code of the function ""message""*:"""" - optional status description } Functions cannot return a reponse with a variable 'function', since it is reserved for server initiated functions. The server can initiate functions on the control channel (rather than the client initiating them).",https://corelink.hsrn.nyu.edu/documentation/protocol-documentation/control-stream-protocol
scraped_data/corelink.hsrn.nyu.edu/documentation_protocol-documentation_control-stream-protocol.html,2,"All modules that communicate on the control channel will have the following basic data format: { ""function""(string):""functionname"", - identify a function to run ""parameter1*"":"""", - parameters of the function ""parameter2*"":"""", parameter names and types can be ""parameterN*"":"""" freely selected for each function } { ""response1*"":"""", - response of the function ""response2*"":"""", response names and types can be ""response""*:"""", freely selected for each function ""statuscode""(integer):XXX, - status code of the function ""message""*:"""" - optional status description }",https://corelink.hsrn.nyu.edu/documentation/protocol-documentation/control-stream-protocol
scraped_data/corelink.hsrn.nyu.edu/about-us_team.html,0,"Dr. Pahle is a senior research scientist at NYU Research Technology. His focus areas are on computer mediated reality infrastructure and applications. Among other things he works on the development of NYU's new High Speed Research Network. Previously he worked at Arizona State Univerity where he was the technical director for the decision theater and later faculty in geography within the GeoDa center. One of his significant milestones in technology development has been the creation of an innovative framework - ChainBuilder - which is capable of integrating disparate models and simulations to holostically interact with and visualize them. In addition, he worked with GIS databases and the parallelization of GIS analytics.",https://corelink.hsrn.nyu.edu/about-us/team
scraped_data/corelink.hsrn.nyu.edu/about-us_team.html,1,"Daniel Braunstein is a graduate student in NYU Steinhardt’s Music Technology program, focused on spatial audio approaches and techniques for XR platforms, integrating his past experience in the games industry in order to bridge the gap between emerging research and practical end-user experience. His current thesis work aims to pioneer and quantify audio-based solutions for “Zoom fatigue”, across a variety of virtual environments and user interfaces. As part of the Corelink and Holodeck teams, Daniel works on extending the existing audio capabilities of Corelink for the C++, Unity, and Unreal clients; plugin development and architecture design; and latency benchmarking against existing Audio-over-IP solutions towards real-time distributed music performance across the NYU campuses.",https://corelink.hsrn.nyu.edu/about-us/team
scraped_data/corelink.hsrn.nyu.edu/about-us_team.html,2,"Sarthak is a master's student at NYU Tandon's Computer Engineering department, with his primary focus areas being robotics and control and all the allied fields in continuation of his undergraduate involvement with competitive and robotics research and embedded devices. Before joining NYU, he worked as a senior developer with BNP Paribas working on sub-millisecond distributed trading systems, front-end systems, NLP-based chatbots, and large-scale storage and database systems. His eventual goal is to work on robotics and hardware-software systems in manufacturing and healthcare domains and making technology accessible, efficient, and affordable. As a part of Corelink, his primary responsibility is the development of the Cpp client and components.",https://corelink.hsrn.nyu.edu/about-us/team
scraped_data/corelink.hsrn.nyu.edu/about-us_team.html,3,"In addition to this, he also contributes to overall Corelink system design and architecture and helping with plugin and server platforms, the Corelink component & technology stack to improve resilience, scalability, efficiency, and system and component modularization. Given his past industry experience, he is also helping to better process efficiency, and formalizing the development process by enabling people to use all tools to their maximum potential is also a part of his role. Outside of work and academics, he enjoys teaching people of all age groups about mathematics, physics, and computer technologies. Accused of being a coffee fiend, he has an unhealthy investment in music streaming services, cooking, cycling, and other activities. Sachin Iyer is an Undergraduate Student at Tandon School of Engineering completing his Bachelor's in Computer Science.",https://corelink.hsrn.nyu.edu/about-us/team
scraped_data/corelink.hsrn.nyu.edu/about-us_team.html,4,"His major technological interests include (although they are ever changing) distributed systems, technological privacy, and intuitive user experiences. For Corelink, he manages and orchestrates the VIP teams, engineers audio solutions, and is involved with Corelink's general architecture. He is also obsessed with his emacs environment, spending way more time on it than he should. He is also interested in cloud technologies, striving to pinch every penny possible. In addition, he has been getting more into blockchains, thinking that it might pave the way for a more private future. Outside of Technology, he is very interested in Jazz, participating in numerous big bands throughout high school including the Stanford Miles Ahead Jazz Orchestra, and still keeps up his trombone skills and works on his electronic music whenever possible. Steven Yoo is a research assistant and software developer at NYU CREATE and NYU Future Reality Lab.",https://corelink.hsrn.nyu.edu/about-us/team
scraped_data/corelink.hsrn.nyu.edu/about-us_team.html,5,"His focus areas include human-computer interaction, accessibility, biometric, and virtual reality. As part of the Corelink and Holodeck teams, Steven works on developing applications to render real-time biometric sensor modules and handling the network infrastructure/storage design on the various platforms, such as web browsers and in the VR environment. Outside of his work, Steven is a game developer and taught high school game development courses for 3 years. Charles Chan is a Computer Science major in my junior year. I expect to graduate in May 2021 with my BS degree. He is a member of the NYU robotics design team, handling the communication between the controller and the robot. His work at NYU IT focuses on the development of the client-side networking library for the high-performance computing research network. Abhishek Khanna is a Research Assistant @NYU IT and masters student @NYU Computer Science department.",https://corelink.hsrn.nyu.edu/about-us/team
scraped_data/corelink.hsrn.nyu.edu/about-us_team.html,6,"He started working for Corelink Project from 2020-2021 primarily adding new functionality to core server and client in Javascript. He is also responsible for a lot of features of the server including the structure of Access controls, Vue Frontend, deploying and adherence to the linting for the project. Apart from his work , he has interest in researching and brainstorming about new technologies, listening to music. Raj Uttam is a graduate student majoring in Computer Science at NYU. His area of interest includes big data and machine learning. During his time at New York University's High-Performance Computing Center, he worked as a software and data engineering research assistant, he developed a framework by writing ETL pipelines using Kafka and ELK to effectively analyze network data generated by Corelight and Zeek. Additionally, as a big data instructor, he tutored students’ to effectively utilize the NYU HPC cluster resources and solve problems using big data frameworks.",https://corelink.hsrn.nyu.edu/about-us/team
scraped_data/corelink.hsrn.nyu.edu/about-us_team.html,7,"As part of the corelink team, he assisted in writing the python client library, developed applications to transmit real-time sensor data using the corelink C++ library, and built dashboards to visualize sensor data from multiple streams using the JavaScript library. In his free time, Raj likes to play Valorant. Aparna is a graduate student majoring in the IDM program at NYU. She works on the Holodeck project in researching ways to augment AR/VR interactions. Aparna works at the NYU Future Reality Lab in designing interactions for AR/VR environments and has been working with the Corelink team in utilizing the network to render real-time sensor interactions on the browser and in the VR space and in documenting the processes to help her research impact people at scale. She owns a patent for the design of an Intelligent Head-Up Display and her works have been cited in various HCI Journals and Conferences.",https://corelink.hsrn.nyu.edu/about-us/team
scraped_data/corelink.hsrn.nyu.edu/about-us_team.html,8,"Apart from her research and academics, she is a motorcycle rider and loves to sketch during her free time. Michael Lukiman is a Full-Stack Software Engineer who worked with Corelink from 2017-2019 during his time at New York University's High Performance Computing Center. He is proud of the work he did spawning processes for cross-platform use of the library, and carries the lessons of real-time, global, & multiagent data streams with him across aspects of career and personal life. Cindy Bui is a Holodeck engineer who worked on Corelink from 2019-2020. She spearheaded the Holodeck concert in March 2020, later moving onto Corelink development and adding several more applications and examples to Corelink. Her work on Corelink includes Infinite, web audio streaming, the C# unity library, C++ audio streaming, video browser streaming, and documentation.",https://corelink.hsrn.nyu.edu/about-us/team
scraped_data/corelink.hsrn.nyu.edu/about-us_team.html,9,"She is a music technologist with a focus on audio programming, GPU acceleration, and system integration - and as a musician/classical percussionist on the side. Iqra Shaikh is a Computer Engineering graduate student at NYU. She worked on the Python development as well as the documentation of Corelink. Her interest areas include Software Development, Web Development and Data Visualization. She is a Forbes Under 30 student scholar. She is also a passionate women’s rights advocate. Ted is a Computer Science graduate student in NYU. He is the full stack developer working on webwork integration for this project. He is skilled in node js, big data processing, network security and react development. Ted enjoys learning new things both on and off the job. He can speak 3 languages professionally(Chinese, English, Japanese) and is learning German as a fourth!",https://corelink.hsrn.nyu.edu/about-us/team
scraped_data/corelink.hsrn.nyu.edu/examples.html,0,"One of the original applications of Corelink was to stream motion capture data from one computer to another using a UDP connection. This was used for several Concerts on the Holodeck using the OptiTrack system. Motion capture data through Corelink to skeleton This performance was in April 2018 hosted by the Music Technology department at NYU Steinhardt, spearheaded by Agnieszka Roginska. This piece is ""Take the A Train."" The trumpet player, pianist, and two dancers were in the Loewe theater, along with the audience. The drummer, bassist, and two other dancers were in the Dolan recording studio, on the 6th floor of the same building. The two dancers in the Dolan recording studio were wearing motion capture suits, and their movements were rendered in real-time as avatars displayed on the screen in Loewe.",https://corelink.hsrn.nyu.edu/examples
scraped_data/corelink.hsrn.nyu.edu/examples.html,1,"The rest of the concert was also distributed with performers split between Dolan and Loewe In October 2018, NYU Steinhardt hosted a concert on the Holodeck as a part of the AES 2018 NYC convention. This performance was a collaboration with NYU Steinhardt Music Technology, NYU Courant FRL, Universidad Nacional De Quilmes from Argentina, Norwegian University of Science and Technology, and Ozark Henry. The dancers were at the FRL and their motion capture was streamed live via Corelink. Corelink has also been used for different motion capture systems, such as the HTC Vive. Motion catpture dancers data through Corelink to Real-time rendering avatars. In a later Holodeck concert, we used iClone and LIVE Face for facial capture streaming using TCP connections. An iPhone was placed in front of a singer with the LIVE Face app. A separate computer was running a program to route the data from LIVE Face to Corelink to the receiver. The receiver rendered the facial capture data using iClone.",https://corelink.hsrn.nyu.edu/examples
scraped_data/corelink.hsrn.nyu.edu/examples.html,2,"Facial capture data through Corelink to Rendered facial capture. There is a C# client that was designed to interface with Corelink to enable any real-time data streaming. These videos are a demo for a multiplayer game where a player's positional data and rotational data are streamed to another person. Multiple players data streaming through Corelink. We have audio streaming capability using WebSockets and UDP connections to stream data from one person to another. This is currently done using C++, Unity, and WebSockets. Our C++ client is currently called CoreTrip and can send audio in real time. This is a video that uses CoreTrip and Unity: Audio streaming through Corelink to changed audio. Infinite is a way to stream audio over the browser and let musicians collaborate. Drums, Piano, and voice audio through Corelink to Recorder. Another focus is on sending 3D data, such as avatar tracking data, audio data, such as voice chat, and affective data, such as heart rate sensors.",https://corelink.hsrn.nyu.edu/examples
scraped_data/corelink.hsrn.nyu.edu/examples.html,3,"Using these capabilities,we have constructed a virtual conference room. Users wearing tracked markers, like Vive trackers, can send their 3D data to the relay, which then sends the data to a plugin to construct an avatar using an IK system similar to Holojam. This avatar data is forwarded to all other members of the virtual conference room, and the avatar is rendered. Additionally, we forward audio data in a similar matter, combining it with the head pose to correctly position the spatialized audio source at the user’s head. In this way, multiple people can sit in the same virtual space with limited motion and speak with each other. Multiple users's 3d model, audio and rendered avatar data streaming through Corelink. One significant application of Corelink involves the graphical representation of sensor data on browsers. Corelink's low latency network framework enables the transfer of data from the client to the server and are plotted as live graphical data on browsers.",https://corelink.hsrn.nyu.edu/examples
scraped_data/corelink.hsrn.nyu.edu/examples.html,4,"Currently we have represented temperature and ultrasonic sensors on the graph. Clients can use any sensor available to them. This application is vital as sensor data from various sources including those from augmented environments can be represented and monitored graphically on browsers. The graph can be viewed as lines and bars with provisions to change colors. It can be zoomed in, zoomed out, and downloaded as a png file. Data through Corelink to live graphical on browser.",https://corelink.hsrn.nyu.edu/examples
scraped_data/corelink.hsrn.nyu.edu/about-us.html,0,"Dr. Pahle is a senior research scientist at NYU Research Technology. His focus areas are on computer mediated reality infrastructure and applications. Among other things he works on the development of NYU's new High Speed Research Network. Previously he worked at Arizona State Univerity where he was the technical director for the decision theater and later faculty in geography within the GeoDa center. One of his significant milestones in technology development has been the creation of an innovative framework - ChainBuilder - which is capable of integrating disparate models and simulations to holostically interact with and visualize them. In addition, he worked with GIS databases and the parallelization of GIS analytics.",https://corelink.hsrn.nyu.edu/about-us
scraped_data/corelink.hsrn.nyu.edu/about-us.html,1,"Daniel Braunstein is a graduate student in NYU Steinhardt’s Music Technology program, focused on spatial audio approaches and techniques for XR platforms, integrating his past experience in the games industry in order to bridge the gap between emerging research and practical end-user experience. His current thesis work aims to pioneer and quantify audio-based solutions for “Zoom fatigue”, across a variety of virtual environments and user interfaces. As part of the Corelink and Holodeck teams, Daniel works on extending the existing audio capabilities of Corelink for the C++, Unity, and Unreal clients; plugin development and architecture design; and latency benchmarking against existing Audio-over-IP solutions towards real-time distributed music performance across the NYU campuses.",https://corelink.hsrn.nyu.edu/about-us
scraped_data/corelink.hsrn.nyu.edu/about-us.html,2,"Sarthak is a master's student at NYU Tandon's Computer Engineering department, with his primary focus areas being robotics and control and all the allied fields in continuation of his undergraduate involvement with competitive and robotics research and embedded devices. Before joining NYU, he worked as a senior developer with BNP Paribas working on sub-millisecond distributed trading systems, front-end systems, NLP-based chatbots, and large-scale storage and database systems. His eventual goal is to work on robotics and hardware-software systems in manufacturing and healthcare domains and making technology accessible, efficient, and affordable. As a part of Corelink, his primary responsibility is the development of the Cpp client and components.",https://corelink.hsrn.nyu.edu/about-us
scraped_data/corelink.hsrn.nyu.edu/about-us.html,3,"In addition to this, he also contributes to overall Corelink system design and architecture and helping with plugin and server platforms, the Corelink component & technology stack to improve resilience, scalability, efficiency, and system and component modularization. Given his past industry experience, he is also helping to better process efficiency, and formalizing the development process by enabling people to use all tools to their maximum potential is also a part of his role. Outside of work and academics, he enjoys teaching people of all age groups about mathematics, physics, and computer technologies. Accused of being a coffee fiend, he has an unhealthy investment in music streaming services, cooking, cycling, and other activities. Sachin Iyer is an Undergraduate Student at Tandon School of Engineering completing his Bachelor's in Computer Science.",https://corelink.hsrn.nyu.edu/about-us
scraped_data/corelink.hsrn.nyu.edu/about-us.html,4,"His major technological interests include (although they are ever changing) distributed systems, technological privacy, and intuitive user experiences. For Corelink, he manages and orchestrates the VIP teams, engineers audio solutions, and is involved with Corelink's general architecture. He is also obsessed with his emacs environment, spending way more time on it than he should. He is also interested in cloud technologies, striving to pinch every penny possible. In addition, he has been getting more into blockchains, thinking that it might pave the way for a more private future. Outside of Technology, he is very interested in Jazz, participating in numerous big bands throughout high school including the Stanford Miles Ahead Jazz Orchestra, and still keeps up his trombone skills and works on his electronic music whenever possible. Steven Yoo is a research assistant and software developer at NYU CREATE and NYU Future Reality Lab.",https://corelink.hsrn.nyu.edu/about-us
scraped_data/corelink.hsrn.nyu.edu/about-us.html,5,"His focus areas include human-computer interaction, accessibility, biometric, and virtual reality. As part of the Corelink and Holodeck teams, Steven works on developing applications to render real-time biometric sensor modules and handling the network infrastructure/storage design on the various platforms, such as web browsers and in the VR environment. Outside of his work, Steven is a game developer and taught high school game development courses for 3 years. Charles Chan is a Computer Science major in my junior year. I expect to graduate in May 2021 with my BS degree. He is a member of the NYU robotics design team, handling the communication between the controller and the robot. His work at NYU IT focuses on the development of the client-side networking library for the high-performance computing research network. Abhishek Khanna is a Research Assistant @NYU IT and masters student @NYU Computer Science department.",https://corelink.hsrn.nyu.edu/about-us
scraped_data/corelink.hsrn.nyu.edu/about-us.html,6,"He started working for Corelink Project from 2020-2021 primarily adding new functionality to core server and client in Javascript. He is also responsible for a lot of features of the server including the structure of Access controls, Vue Frontend, deploying and adherence to the linting for the project. Apart from his work , he has interest in researching and brainstorming about new technologies, listening to music. Raj Uttam is a graduate student majoring in Computer Science at NYU. His area of interest includes big data and machine learning. During his time at New York University's High-Performance Computing Center, he worked as a software and data engineering research assistant, he developed a framework by writing ETL pipelines using Kafka and ELK to effectively analyze network data generated by Corelight and Zeek. Additionally, as a big data instructor, he tutored students’ to effectively utilize the NYU HPC cluster resources and solve problems using big data frameworks.",https://corelink.hsrn.nyu.edu/about-us
scraped_data/corelink.hsrn.nyu.edu/about-us.html,7,"As part of the corelink team, he assisted in writing the python client library, developed applications to transmit real-time sensor data using the corelink C++ library, and built dashboards to visualize sensor data from multiple streams using the JavaScript library. In his free time, Raj likes to play Valorant. Aparna is a graduate student majoring in the IDM program at NYU. She works on the Holodeck project in researching ways to augment AR/VR interactions. Aparna works at the NYU Future Reality Lab in designing interactions for AR/VR environments and has been working with the Corelink team in utilizing the network to render real-time sensor interactions on the browser and in the VR space and in documenting the processes to help her research impact people at scale. She owns a patent for the design of an Intelligent Head-Up Display and her works have been cited in various HCI Journals and Conferences.",https://corelink.hsrn.nyu.edu/about-us
scraped_data/corelink.hsrn.nyu.edu/about-us.html,8,"Apart from her research and academics, she is a motorcycle rider and loves to sketch during her free time. Michael Lukiman is a Full-Stack Software Engineer who worked with Corelink from 2017-2019 during his time at New York University's High Performance Computing Center. He is proud of the work he did spawning processes for cross-platform use of the library, and carries the lessons of real-time, global, & multiagent data streams with him across aspects of career and personal life. Cindy Bui is a Holodeck engineer who worked on Corelink from 2019-2020. She spearheaded the Holodeck concert in March 2020, later moving onto Corelink development and adding several more applications and examples to Corelink. Her work on Corelink includes Infinite, web audio streaming, the C# unity library, C++ audio streaming, video browser streaming, and documentation.",https://corelink.hsrn.nyu.edu/about-us
scraped_data/corelink.hsrn.nyu.edu/about-us.html,9,"She is a music technologist with a focus on audio programming, GPU acceleration, and system integration - and as a musician/classical percussionist on the side. Iqra Shaikh is a Computer Engineering graduate student at NYU. She worked on the Python development as well as the documentation of Corelink. Her interest areas include Software Development, Web Development and Data Visualization. She is a Forbes Under 30 student scholar. She is also a passionate women’s rights advocate. Ted is a Computer Science graduate student in NYU. He is the full stack developer working on webwork integration for this project. He is skilled in node js, big data processing, network security and react development. Ted enjoys learning new things both on and off the job. He can speak 3 languages professionally(Chinese, English, Japanese) and is learning German as a fourth!",https://corelink.hsrn.nyu.edu/about-us
scraped_data/corelink.hsrn.nyu.edu/about-us_collaborators.html,0,Home Examples Documentation Technical Overview Client Documentation Server Documentations Client Initiated Control Functions Server Initiated Control Functions Corelink Plugins Protocol Documentation Control Stream Protocol Data Stream Protocol Next Steps Get Started Contributing to Corelink Naming Convention Guidelines About Us Team Collaborators Support Contact Us Corelink - Real Time Networking for Research. Home Examples Documentation Technical Overview Client Documentation Server Documentations Client Initiated Control Functions Server Initiated Control Functions Corelink Plugins Protocol Documentation Control Stream Protocol Data Stream Protocol Next Steps Get Started Contributing to Corelink Naming Convention Guidelines About Us Team Collaborators Support Contact Us,https://corelink.hsrn.nyu.edu/about-us/collaborators
scraped_data/corelink.hsrn.nyu.edu/next-steps_naming-convention-guidelines.html,0,"Globally The exceptions to the camel case rule are username and streamid. Functions: Common function uses and names: Ordering of function names: Singular or plural: Variable Names Input Values: The exceptions are the variables username, functionName. Result values: Result values should be ordered object of interest first and then type. The object of interest should be singular. Example: userList, workspaceList Object names should just use the object word without ‘name’ attached. For example, usernames or workspace names are returned, we shorten to: userList, workspaceList If the function returns an array of user names we shorten to object name. For example we return a list of usernames and app names: [ user, app ] If we have an array inside an array we will use the object in plural. For example we want to return [user, [app]], we name the return: [user, apps] Should it be called a workspace or room? It should be called a workspace.",https://corelink.hsrn.nyu.edu/next-steps/naming-convention-guidelines
scraped_data/corelink.hsrn.nyu.edu/next-steps_naming-convention-guidelines.html,1,"Should the first letter if functions be capital (addUser vs AddUser)? No, it should be addUser. Should results of arrays be plural (usersList vs. userList)? No it should be userList. Should function names be plural (listUsers vs. listUser)? Yes, it should be listUsers Result variables should include ‘name’ (e.g. usernameList vs userList)? No, here we are removing the name and it will be userList. There is one exception and that is username. Shall we make an exception for username (instead of calling it user)? Yes, we will make the exception for username. Should variable names be camel case (userList vs. userlist)? Yes, it should be userList. ,",https://corelink.hsrn.nyu.edu/next-steps/naming-convention-guidelines
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_server.html,0,Corelink Documentation Server Initializing search GitLab Corelink Documentation GitLab Introduction Understand Getting started tutorials Getting started tutorials Server Bash Browser C++ C# JavaScript Python How To How To Run Corelink Server from source Generate certificates Contribute Contribute How To: Create a merge request Community Guidelines Contact Server,https://corelink-docs.hsrn.nyu.edu/getting-started/server
scraped_data/corelink-docs.hsrn.nyu.edu/contribute_merge.html,0,Create a Merge Request Create a fork Create the new repository Commit your changes/do your development Create a merge request Compare changes Submit Merge Request Wait for approval,https://corelink-docs.hsrn.nyu.edu/contribute/merge
scraped_data/corelink-docs.hsrn.nyu.edu/understand.html,0,"Understanding Corelink's Architecture What is Corelink Corelink is a programmable low-latency messaging platform. It is intended to be a powerful communication layer to connect real-time applications such as audio, video, motion capture, virtual reality, etc. Instead of creating ad-hoc communication protocols for your programs, Corelink allows you to connect many different types of applications, taking care of selecting the streams your application can consume based on their metadata. Corelink also allows the user to wire streams on the fly and inserting plugins that process, filter, mix, or re-encode streams on the server. Components Corelink consists of clients, implemented via one of our libraries or following our simple protocol, a server to which clients connect and which organizes the routing of messages, and relays which do the actual forwarding and can be provided by the server process in the simplest case.",https://corelink-docs.hsrn.nyu.edu/understand
scraped_data/corelink-docs.hsrn.nyu.edu/understand.html,1,"Clients and relays communicate with the server over a simple JSON-based RPC protocol over TCP or WebSocket: the control protocol. The server can optionally receive credentials to authenticate clients and restrict their access level. Corelink messages are exchanged between clients and relays over a simple binary protocol over TCP, UDP, or WebSocket. Messaging concepts Data is routed through streams. To publish data, a client creates a sender stream with the server and receives a stream ID that it can use to send messages through a relay. Similarly, to receive data, a client creates a receiver stream with the server that it can use to consume data from a relay. Sender streams are associated with tags that are commonly used to identify the type of data that is sent through, for example audio , mp4 , motioncap , etc. When creating a receiver, you can express your interest in specific tags, which will allow you to subscribe to those streams automatically.",https://corelink-docs.hsrn.nyu.edu/understand
scraped_data/corelink-docs.hsrn.nyu.edu/index.html,0,"Introduction What is Corelink Corelink is a programmable low-latency messaging platform for real-time research applications. You can use it to selectively broadcast messages between producers and consumers with low latency across a variety of platforms. With Corelink, you can easily organize and connect streams by type, either manually or programmatically, and configure plugins to apply processing or filters to streams on the server. You can read more about Corelink's architecture or get started with one of our client libraries now. Contributing to Corelink Corelink is open-source, distributed under the MIT license. Check out the code on GitLab or learn how to contribute. Corelink is developed by the High Speed Research Network team at New York University. Learn more about the team or contact us here. Sample use-cases Corelink is meant to accomodate a wide variety of use-cases and applications, in a single location or across the internet.",https://corelink-docs.hsrn.nyu.edu/index
scraped_data/corelink-docs.hsrn.nyu.edu/index.html,1,"Motion capture streaming One of the original applications of Corelink was to stream motion capture data from one computer to another using a UDP connection. This was used for several Concerts on the Holodeck using the OptiTrack system. Concerts on the Holodeck This performance was in April 2018 hosted by the Music Technology department at NYU Steinhardt, spearheaded by Agnieszka Roginska. This piece is ""Take the A Train."" The trumpet player, pianist, and two dancers were in the Loewe theater, along with the audience. The drummer, bassist, and two other dancers were in the Dolan recording studio, on the 6th floor of the same building. The two dancers in the Dolan recording studio were wearing motion capture suits, and their movements were rendered in real-time as avatars displayed on the screen in Loewe. The rest of the concert was also distributed with performers split between Dolan and Loewe.",https://corelink-docs.hsrn.nyu.edu/index
scraped_data/corelink-docs.hsrn.nyu.edu/index.html,2,"In October 2018, NYU Steinhardt hosted a concert on the Holodeck as a part of the AES 2018 NYC convention. This performance was a collaboration with NYU Steinhardt Music Technology, NYU Courant FRL, Universidad Nacional De Quilmes from Argentina, Norwegian University of Science and Technology, and Ozark Henry. The dancers were at the FRL and their motion capture was streamed live via Corelink. Corelink has also been used for different motion capture systems, such as the HTC Vive. Facial Capture Streaming In a later Holodeck concert, we used iClone and LIVE Face for facial capture streaming using TCP connections. An iPhone was placed in front of a singer with the LIVE Face app. A separate computer was running a program to route the data from LIVE Face to Corelink to the receiver. The receiver rendered the facial capture data using iClone. Unity + Corelink There is a C# client that was designed to interface with Corelink to enable any real-time data streaming.",https://corelink-docs.hsrn.nyu.edu/index
scraped_data/corelink-docs.hsrn.nyu.edu/index.html,3,"These videos are a demo for a multiplayer game where a player's positional data and rotational data are streamed to another person. Audio streaming We have audio streaming capability using WebSockets and UDP connections to stream data from one person to another. This is currently done using C++, Unity, and WebSockets. Our C++ client is currently called CoreTrip and can send audio in real time. This is a video that uses CoreTrip and Unity: Infinite Infinite is a way to stream audio over the browser and let musicians collaborate. Vive Avatar Another focus is on sending 3D data, such as avatar tracking data, audio data, such as voice chat, and affective data, such as heart rate sensors. Using these capabilities,we have constructed a virtual conference room. Users wearing tracked markers, like Vive trackers, can send their 3D data to the relay, which then sends the data to a plugin to construct an avatar using an IK system similar to Holojam.",https://corelink-docs.hsrn.nyu.edu/index
scraped_data/corelink-docs.hsrn.nyu.edu/index.html,4,"This avatar data is forwarded to all other members of the virtual conference room, and the avatar is rendered. Additionally, we forward audio data in a similar matter, combining it with the head pose to correctly position the spatialized audio source at the user’s head. In this way, multiple people can sit in the same virtual space with limited motion and speak with each other. Real-Time Sensor Data Representation on Browser One significant application of Corelink involves the graphical representation of sensor data on browsers. Corelink's low latency network framework enables the transfer of data from the client to the server and are plotted as live graphical data on browsers. Currently we have represented temperature and ultrasonic sensors on the graph. Clients can use any sensor available to them. This application is vital as sensor data from various sources including those from augmented environments can be represented and monitored graphically on browsers.",https://corelink-docs.hsrn.nyu.edu/index
scraped_data/corelink-docs.hsrn.nyu.edu/index.html,5,"The graph can be viewed as lines and bars with provisions to change colors. It can be zoomed in, zoomed out, and downloaded as a png file.",https://corelink-docs.hsrn.nyu.edu/index
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_cpp.html,0,Installation Instructions General Instructions The current C++ Corelink Client has three direct external dependencies - Libwebsockets - compilation required Depends on one of the following: - OpenSSL - v1.1.1 - MbedTLS - Latest - LibreSSL - Latest - WolfSSL - Latest - Asio C++ - header only - RapidJSON - header only You can get some of the dependencies from External Dependencies Repo,https://corelink-docs.hsrn.nyu.edu/getting-started/cpp
scraped_data/corelink-docs.hsrn.nyu.edu/contribute_community-guidelines.html,0,"Community Guidelines Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.",https://corelink-docs.hsrn.nyu.edu/contribute/community-guidelines
scraped_data/corelink-docs.hsrn.nyu.edu/contribute_community-guidelines.html,1,"Our Standards Examples of behavior that contributes to creating a positive environment include: - Using welcoming and inclusive language - Being respectful of differing viewpoints and experiences - Gracefully accepting constructive criticism - Focusing on what is best for the community - Showing empathy towards other community members Examples of unacceptable behavior by participants include: - The use of sexualized language or imagery and unwelcome sexual attention or advances - Trolling, insulting/derogatory comments, and personal or political attacks - Public or private harassment - Publishing others' private information, such as a physical or electronic address, without explicit permission - Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.",https://corelink-docs.hsrn.nyu.edu/contribute/community-guidelines
scraped_data/corelink-docs.hsrn.nyu.edu/contribute_community-guidelines.html,2,"Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project head Robert Pahle or nyu at the Office of Equal Opportunity.",https://corelink-docs.hsrn.nyu.edu/contribute/community-guidelines
scraped_data/corelink-docs.hsrn.nyu.edu/contribute_community-guidelines.html,3,"All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available here For answers to common questions about this code of conduct, see this.",https://corelink-docs.hsrn.nyu.edu/contribute/community-guidelines
scraped_data/corelink-docs.hsrn.nyu.edu/deploy-certificate-guide.html,0,"Connecting to a personal remote Corelink instance The problem Trying to connect to a Corelink server other than corelink.hpc.nyu.edu or localhost (127.0.0.1 ) is unsuccessful. Solution When attempting to connect to a remote computer running Corelink server, a new certificate file must be generated on the server and the public key must be shared to the client. This guide will go over how to generate the new certificates and how to use it on the javascript client. Generating new certificates - Open corelink/server/config/server.cnf and add a line for the IP of the server under[alt_names] .",https://corelink-docs.hsrn.nyu.edu/deploy-certificate-guide
scraped_data/corelink-docs.hsrn.nyu.edu/deploy-certificate-guide.html,1,"Also change the Common Name (CN ) field under[ req_distinguished_name ] to the IP of the server.Example server.cnf [ req ] default_bits = 4096 days = 9999 distinguished_name = req_distinguished_name attributes = req_attributes prompt = no basicConstraints = CA:FALSE req_extensions = req_ext [ req_distinguished_name ] C = US ST = NY L = NYC O = NYU OU = RT CN = 10.20.200.40 emailAddress = certs@example.com [ req_attributes ] challengePassword = password [ issuer_info ] OCSP;URI.0 = http://ocsp.example.com/ caIssuers;URI.0 = http://example.com/ca.cert [ req_ext ] subjectAltName = @alt_names [alt_names] IP.1 = 127.0.0.1 DNS.2 = localhost IP.3 = ::1 IP.4 = 10.20.200.40 - Once the config is changed, generate new certificates using the following commands: Click to see certificate generation commands CA Key openssl genrsa -out ca-key.pem 4096 Create CA openssl req -new -x509 -key ca-key.pem -days 9999 -out ca-crt.pem -config ca.cnf Create CSR openssl req -nodes -new -days 9999 -config server.cnf -keyout server-key.pem -out server-csr.pem Sign openssl x509 -req -days 9999 -extfile server.cnf -extensions req_ext -in server-csr.pem -CA ca-crt.pem -CAkey ca-key.pem -CAcreateserial -out server-crt.pem Test for alternative names openssl req -in server-csr.pem -noout -text Check Cert openssl verify -CAfile ca-crt.pem server-crt.pem - After generating new certificates on the server, copy the public key ca-crt.pem from the server to the device clients will connect from.",https://corelink-docs.hsrn.nyu.edu/deploy-certificate-guide
scraped_data/corelink-docs.hsrn.nyu.edu/deploy-certificate-guide.html,2,"Using the new certificate on the client. - Change the ControlIP in the corelink/config/default.json5 file to the IP of the server.Example default.json5 { // corelink server control port // IP Port // ControlPort: 20010, // WS Port ControlPort: 20012, // corelink server ip address ControlIP: '10.20.200.40', // automatically recconnect control connection autoReconnect: false, // comment this line, if you dont use 127.0.0.1 for testing. A valid // certificate on the server side is required. // Change the certificate authority if you are using a server with self // signed certificate. cert: 'path/to/ca-crt.pem' } - In the connect function add a parameter for the absolute file path to the certificate file on the client. An example can be seen here",https://corelink-docs.hsrn.nyu.edu/deploy-certificate-guide
scraped_data/corelink-docs.hsrn.nyu.edu/contact.html,0,"Contact Join our chat room We use Matrix for our internal chat, this is the best place to ask general questions and meet the team: #corelink:hsrn.nyu.edu Project Administration Project Manager Leadership for the VIP student team (Vertically Integrated Projects at NYU) - Sachin Iyer - Zack Nguyen - Akash Datta Sub-project Maintainers - Bash Client: Sachin Iyer - Browser Client: Zack Nguyen - C++ Client: Sarthak Tickoo - C# Client: Sarthak Tickoo - JavaScript Client: Sachin Iyer - Python Client: IN PROGRESS - Server: Rob Pahle",https://corelink-docs.hsrn.nyu.edu/contact
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_csharp.html,0,Installation Instructions General Instructions One of the following: nuget install corelink - IN PROGRESS Usage Instructions API reference API Documentation,https://corelink-docs.hsrn.nyu.edu/getting-started/csharp
scraped_data/corelink-docs.hsrn.nyu.edu/try-browser.html,0,Corelink Documentation Type to start searching GitLab Corelink Documentation GitLab Introduction Understand Getting started tutorials Getting started tutorials Server Bash Browser C++ C# JavaScript Python How To How To Run Corelink Server from source Generate certificates Contribute Contribute How To: Create a merge request Community Guidelines Contact 404 - Not found,https://corelink-docs.hsrn.nyu.edu/try-browser
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started.html,0,"Getting started To use corelink, you will need a server and a client (either our official clients or a 3rd party client). There is a testing server (not to be used for production applications) deployed at corelink.hsrn.nyu.edu . Official Clients Installation instructions, API references, and simple examples are listed on each client's page We also have a simple example for each of the languages. If you want to see some more examples, please visit our example browser. Client List Unofficial Clients Contact us to have your client listed here",https://corelink-docs.hsrn.nyu.edu/getting-started
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_bash.html,0,Installation Instructions General Instructions You will need to install the following: jq socat websocat Usage Instructions API reference API Documentation,https://corelink-docs.hsrn.nyu.edu/getting-started/bash
scraped_data/corelink-docs.hsrn.nyu.edu/deploy.html,0,Installing the Corelink Server Install the Corelink Server with Docker IN PROGRESS Install the Corelink Server with Helm IN PROGRESS Install the Corelink Server with Node IN PROGRESS Install the Corelink Server from Source Required Software - Git - NodeJS 16 (please install the current version and enable compilation support) - Python (required by NPM) Clone the repository and go into repository folder Install dependencies and fix potential bugs Enable config file for the database Linux/Mac: Windows: Create database with latest tables Seed database with basic data Warning: All existing data inside the database will be deleted. Start server Test sending and receiving packages After starting the server the sender and receiver scripts can be used to test the server. These are in the corelink-tools repository. In separate terminals next to the server start both applications.,https://corelink-docs.hsrn.nyu.edu/deploy
scraped_data/corelink-docs.hsrn.nyu.edu/deploy.html,1,"First start the sender: When the sender starts the first time it will ask for the IP address to connect to the server. In this example use 127.0.0.1, then press enter twice to use the preset username and password.Then start the listener: It should not ask for the IP adresses again. Just press enter twice to start the appliaction.Upgrade instructions for the Corelink Server Pull latest version Update database to latest table version Upgrade instructions for the Corelink Server DURING DEVELOPMENT simply run from within networktest Warning: All existing data inside the database will be deleted. you can also use separate commands to do the migrations: run the rollback until you are at the beginning of the migrations Warning: All existing data inside the database will be deleted. then migrate and seed ``` Warning: All existing data inside the database will be deleted.",https://corelink-docs.hsrn.nyu.edu/deploy
scraped_data/corelink-docs.hsrn.nyu.edu/try-browser-browser_examples.html,0,Corelink Documentation Type to start searching GitLab Corelink Documentation GitLab Introduction Understand Getting started tutorials Getting started tutorials Server Bash Browser C++ C# JavaScript Python How To How To Run Corelink Server from source Generate certificates Contribute Contribute How To: Create a merge request Community Guidelines Contact 404 - Not found,https://corelink-docs.hsrn.nyu.edu/try-browser-browser/examples
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_python.html,0,"Python Installation Instructions General Instructions One of the following (with python3 ): pip install corelink Usage Instructions API reference Setting up Corelink First, import Corelink: import corelink Environment The corelink module runs on the async protocol, so all calls must be run in an async context. What this means is that you should define an asynchronous function, such as async def foo(): , and put all the code there, and then run that function with corelink.run(foo()) in order to initialize the asyncio process. Additionally, all corelink function calls should be made using the await keyword for them to work properly.",https://corelink-docs.hsrn.nyu.edu/getting-started/python
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_python.html,1,"Control stream Now, in your async context manager (like the foo() esxample above) you should run corelink.connect with the necessary parameters: * username is your username * password is your password * host is the host address of the server to connecting to * port is the server port to connect to This function will connect to the server and initialize the control stream. If the authentication to the server fails, corelink will raise an error. Various control functions can now be called to request information from or make changes to the server, as are detailed here. Sending data To send data over Corelink, you should first call create_sender with the necessary parameters: * workspace, protocol: str = ""tcp"", streamID="""", data_type='', metadata='', sender="""", ip="""", port="""" * workspace is the Corelink workspace you want to send data in. * protocol is the internet protocol you want to send over; currently, TCP ['tcp' ] and UDP ['udp' ] are supported. If omitted, tcp is selected by default.",https://corelink-docs.hsrn.nyu.edu/getting-started/python
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_python.html,2,"* Optional parameters: * streamID can be used to update an existing sender with these new settings as opposed to creating a new one. * data_type will specify a data type, so that receivers can 'subscribe' to only a particular type. * metadata is an optional parameter to give some metadata. * sender can be passed a name for the sender. * ip is the user's ip. * port is the user's port. A connection will then be established with the server, if all goes well, and the sender's streamID will be returned to the user. This ID is used to call any functions on this stream, so don't lose it. But if you do, you can call active_streams to return a list of all the active streams' IDs. After all this si set up, data can be sent using the send function with: * the streamID you want to send from * the data you want to send, which should be either a str or bytes object * an optional user_header to pass a dict with some header information. That's it!",https://corelink-docs.hsrn.nyu.edu/getting-started/python
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_python.html,3,"Receiving data If you want to receive data, you should first create the necessary async callback function for data. It should expect data: bytes, streamID: int, header: dict and do whatever you want to do with the data. After defining that function, it should be passed into the set_data_callback function. Then you should similarly call create_receiver with workspace, protocol, data_type, metadata, receiver_id, ip, port as explained above, and some more optional parameters: * stream_ids can be passed a list of streamID s from which to receive data. * alert can be passed True to let the client know if a new stream of its type is created. * echo can be passed True to receive streams sent from the same username . You should then begin receiving whatever data might come your way. Sever control functions The server also sometimes sends messages to you over the control channel.",https://corelink-docs.hsrn.nyu.edu/getting-started/python
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_python.html,4,"You can handle these messages by writing async callbacks expecting a message: dict from the server and key: str identifying the type of message received, and then passing that callback into set_server_callback along with the appropriate key . Details on these server messages can be found here. Finishing up When you're done, Corelink will automatically destroy all active streams and close down your connection. You can also initiate this process with a Keyboard Interrupt. Lastly Full simple examples can be found here, and the client documentation is available here",https://corelink-docs.hsrn.nyu.edu/getting-started/python
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_javascript.html,0,"Installation Instructiosn General Instructions One of the following: npm install corelink-client Importing Usage Instructions API reference TCP Sender and Receiver Walkthrough Sender Walkthrough After importing Corelink, you first define some constants. You need a server and a certificate that authenticates into that server in order to send data if you are using a self signed certificate on the server side. If you have a certificate that is signed by a trusted certification authority you only need a server without the need to have a certificate. You will also need to set up Corelink username, password, and most importantly importing it.",https://corelink-docs.hsrn.nyu.edu/getting-started/javascript
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_javascript.html,1,"const config = { ControlPort: 20012, /* ControlIP: '127.0.0.1', */ ControlIP: 'corelink.hpc.nyu.edu', autoReconnect: false, /* for service in a local network please replace the certificate with the appropriate version cert: '<corelink-tools-repo>/config/ca-crt.pem' */ } const username = 'Testuser' const password = 'Testpassword' The 3 protocols Corelink currently supports are tcp (TCP), udp (UDP), and ws (Web Socket). Any of the three could be used in the protocol field In our example we have a random data function to just generate some sample data, so here it is. This is the function that is actually used to send data. The steps in order are 1. Connect to the server using a username/password and the constansts that we defined before 2. Create a sender that you can send data with 3. Send data with that sender (this is thesetInterval() function) 4.",https://corelink-docs.hsrn.nyu.edu/getting-started/javascript
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_javascript.html,2,"Using the Corelink on function to receive call back from receiver, such that the sender will only start sending when at least one receiver is present in the same workspace. The sender's callback function prevents sending data to an empty workspace. It sets the receiverActive flag to true when a valid receiver is present, ensuring data is only sent when it can be received. const run = async () => { if (await corelink.connect({ username, password }, config).catch((err) => { console.log(err) })) { sender = await corelink.createSender({ workspace, protocol, type: datatype, metadata: { name: 'Random Data' }, }).catch((err) => { console.log(err) }) // Provide the sender update callback.",https://corelink-docs.hsrn.nyu.edu/getting-started/javascript
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_javascript.html,3,"corelink.on('sender', (data) => { console.log('Sender update:', data) if (data.receiverID) { receiverActive = true } else { receiverActive = false } }) setInterval(async () => { if (receiverActive && sender) { const dataToSend = Buffer.from(randomdata()); await corelink.send(sender, dataToSend); console.log('Data sent:', dataToSend.toString()); } }, 1000); } } run() Receiver Walkthrough After importing Corelink, you first define some constants. You need a server and a certificate that authenticates into that server in order to send data if you are using a self signed certificate on the server side. If you have a certificate that is signed by a trusted certification authority you only need a server without the need to have a certificate. You will also need to set up Corelink username, password, and most importantly importing it.",https://corelink-docs.hsrn.nyu.edu/getting-started/javascript
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_javascript.html,4,"const config = { ControlPort: 20012, /* ControlIP: '127.0.0.1', */ ControlIP: 'corelink.hpc.nyu.edu', autoReconnect: false, /* for service in a local network please replace the certificate with the appropriate version cert: '<corelink-tools-repo>/config/ca-crt.pem' */ } const username = 'Testuser' const password = 'Testpassword' const run = async () => { if (await corelink.connect({ username, password }, config).catch((err) => { console.log(err) })) { await corelink.createReceiver({ workspace, protocol, type: datatype, echo: true, alert: true, }).catch((err) => { console.log(err) }) corelink.on('receiver', async (data) => { const options = { streamIDs: [data.streamID] } await corelink.subscribe(options) }) corelink.on('data', (streamID, data, header) => { console.log(streamID, data.toString(), JSON.stringify(header)) }) } } run() One sender can send data to multiple receivers, however it can only send one stream, versus a receiver can receive multiple streams at the same time.",https://corelink-docs.hsrn.nyu.edu/getting-started/javascript
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_javascript.html,5,These streams are by default from multiple senders as each sender can only send one stream. Source You can read the code in the examples repository,https://corelink-docs.hsrn.nyu.edu/getting-started/javascript
scraped_data/corelink-docs.hsrn.nyu.edu/contribute.html,0,"How to Contribute Corelink is an open source project. We welcome and encourage improvements in all forms. These include, and certainly not limited to - Bug reports - Discussion on future direction and features - Proposing and submitting a fix - Maintaining - Porting - Toolchain improvements - Documentation - Technology and library improvements or adaptation All of the source code, documents, artifacts are hosted on a self-managed GitLab instance, which you can find here. We raise our issues, and maintain documents and all other relevant material via GitLab.",https://corelink-docs.hsrn.nyu.edu/contribute
scraped_data/corelink-docs.hsrn.nyu.edu/contribute.html,1,"Submit an Example to the Example Browser We would love to include your example in the example browser site - Follow our Community Guidelines - Create an issue - Create a Merge Request in the corelink examples repo - Interact with the team to get approved Contribute to the main Corelink Project - Follow our Community Guidelines - Create an issue - Write code following our styles - Create a Merge Request - Interact with the team to get approved Programming style We use guides from others, because they are tested and proven to work. Please follow them when writing code for the project. - NodeJS and JavaScript Which follows airbnb - PEP8 Python Style Guide from GVR - Google C++ style guide - MSFT C# Style guide Community Guidelines We aim to create a safe, inclusive, and productive environment. As such we follow the Contributor Covenant Our version is on the next page",https://corelink-docs.hsrn.nyu.edu/contribute
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_browser.html,0,"Installation Intructions General Instructions Include the client link Include client in HTML <script src=""https://corelink.hsrn.nyu.edu/client/browser/corelink.browser.lib.js""></script> Include client locally (download first) <script src=""./corelink.browser.lib.js""></script> Usage Instructions API reference Quickstart 1. Authentication To create a new sender/receiver stream or call any miscellaneous corelink function, you first have to provide the appropriate credentials to be authenticated to the server. corelink.connect({username: ""Testuser"", password: ""Testpassword""}, {ControlIP: ""corelink.hpc.nyu.edu"", ControlPort: 20012}) The corelink.connect() function takes two objects as parts of its parameters. The first object contains the username and password attributes, which in the example above holds the values ""Testuser"" and ""Testpassword"", respectively. The second object contains the ControlIP and ControlPort attributes.",https://corelink-docs.hsrn.nyu.edu/getting-started/browser
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_browser.html,1,"The most commonly used ControlIP or host is the corelink's remote server ""corelink.hpc.nyu.edu"". In this case, we also choose to use the port 20012 because ... Once the request is successfully sent, a response {statusCode: 0, token: '6385bfaadfc9297456277259f66445bfa717c28d520f651d318c1b1af47ab1d1', IP: '10.18.151.121'} as such should be returned from the corelink.browser.lib.js file. 2. Sender & Receiver Inquire our technical-overview to better understand the sender and receiver workflow. Sender and Receiver explanations can be found here. 3. Others All functions in the browser client are string-based an can be called using corelink.generic({}) . Examples: Listing all available functions from the corelink browser client corelink.generic({function: ""listFunctions""}) Listing all users registered to the corelink server corelink.genetic({function: ""listUsers""}) Listing the streams correspond to the configured workspace/stream_type/meta.",https://corelink-docs.hsrn.nyu.edu/getting-started/browser
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_browser.html,2,"corelink.generic({function: ""listStreams""}) Simple Websocket Sender/Receiver Example Explanation Follow this walkthrough after you have completed the installation instructions found here Sender Global variable senderId let senderId; The corelink.createSender() method returns the stream's id which can set to senderId senderId = corelink.createSender({workspace: 'Holodeck', protocol: 'ws', type: ""testdata"", echo: false, alert: false}) The TextEncoder().encode() method converts the Javascript string value to an array of type uint8 which we can then pass into corelink.send() along with the streamId to send across the stream async function send(){ let str = document.getElementById(""msg"").value; var uint8array = new TextEncoder().encode(str); corelink.send(senderId, uint8array) await sleep(1000) } Receiver corelink.receiver() asks for an object containing the specified workspace, protocol, and stream type of the desired stream await corelink.createReceiver({ workspace: ""Holodeck"", protocol: ""ws"", type: ""testdata"", echo: true, alert: true }).catch((err) => { console.log(err) }) The corelink.on() is a method used to trigger specific callback function.",https://corelink-docs.hsrn.nyu.edu/getting-started/browser
scraped_data/corelink-docs.hsrn.nyu.edu/getting-started_browser.html,3,"The corelink.on('receiver', ...) triggers the receiver callback function that returns a data object containing the streamID that you can subscribe to to officially establish a connection with the stream. corelink.on('receiver', async (data) => { await corelink.subscribe([data.streamID]) }) Using TextDecoder to decode the incoming data in ""utf-8"" format corelink.on('data', (streamID, encoding) => { var string = new TextDecoder(""utf-8"").decode(encoding); if (string != myString && string!=""#""){ myString = string; document.getElementById(""msg"").innerHTML = string; } })",https://corelink-docs.hsrn.nyu.edu/getting-started/browser
scraped_data/k8s-docs.hsrn.nyu.edu/flask-service.html,0,"Build and deploy a Flask application Introduction This tutorial will take you through building and deploying a simple web application on the cluster, which will be reachable from the internet. It is built with the Python Flask framework, but many steps are not specific to Python or Flask. To go through this tutorial, you will need access to the Kubernetes cluster; see Get Started. You will also need Docker on your machine. Write the code This simple application does nothing but give the current time. Put the code in a file clock.py : from datetime import datetime from flask import Flask import pytz app = Flask('clock') timezone = pytz.timezone('America/New_York') @app.route('/') def index(): now_utc = pytz.utc.localize(datetime.utcnow()) now_nyc = now_utc.astimezone(timezone) return ""In New York, it is currently "" + now_nyc.strftime('%H:%M:%S') If you have Python on your machine, you can install Flask and pytz and run this app with FLASK_APP=clock flask run .",https://k8s-docs.hsrn.nyu.edu/flask-service
scraped_data/k8s-docs.hsrn.nyu.edu/flask-service.html,1,"However that is not required to continue. Build a container image with Docker Create the following Dockerfile in the same directory. This file contains the steps that will create a container image, that we can later deploy on Kubernetes or any other platform that supports containers: # Start from the Python image, automatically retrieved from Docker Hub FROM python:3.10 # Install our dependencies, by running a command in the container RUN pip install flask pytz uwsgi # Add our application's code RUN mkdir /usr/src/app WORKDIR /usr/src/app COPY clock.py /usr/src/app/ # Have containers serve the application with uwsgi by default EXPOSE 5000 CMD [""uwsgi"", ""--http"", "":5000"", ""-w"", ""clock:app""] You can now build the image from this file by running this command: You should now be able to run this container locally with the following: Push the image to a container registry In order for the cluster to be able to get your container image, you have to put it on a registry.",https://k8s-docs.hsrn.nyu.edu/flask-service
scraped_data/k8s-docs.hsrn.nyu.edu/flask-service.html,2,"There are multiple free registries available, such as Docker Hub (200 image downloads per 6 hours for free) or Red Hat Quay.io (unlimited for public repositories). GitLab and GitHub also include their own free registries. In this case we will use HSRN's GitLab instance dev.hsrn.nyu.edu, which you can access with your NYU account. Tag your images with the registry and a unique name (most registries will give you a prefix with your username or your project's name) and upload it: $ docker tag flask-clock registry.hsrn.nyu.edu/myusername/flask-clock $ docker push registry.hsrn.nyu.edu/myusername/flask-clock $ # or for quay.io: $ docker tag flask-clock quay.io/myusername/flask-clock $ docker push quay.io/myusername/flask-clock Create the Deployment We are now ready to run containers on the cluster. On Kubernetes, the smallest unit of workload is a Pod, which can be multiple containers sharing a single network namespace (e.g. they can see each other as ""localhost"").",https://k8s-docs.hsrn.nyu.edu/flask-service
scraped_data/k8s-docs.hsrn.nyu.edu/flask-service.html,3,"Running a Pod with a single container is very common. A Pod runs to completion or until its liveness probe fails and is not recreated automatically. To make sure our application stays available, we will wrap it in a Deployment which can run multiple copies of the Pod (for performance), will keep the target number of Pods available (including starting more copies as soon as some go down due to host maintenance or preemption), and can perform rolling updates (changing to a new container image version with no downtime).",https://k8s-docs.hsrn.nyu.edu/flask-service
scraped_data/k8s-docs.hsrn.nyu.edu/flask-service.html,4,"Write this manifest to deployment.yml : apiVersion: apps/v1 kind: Deployment metadata: name: flask-clock labels: app: flask-clock source: hsrn-tutorial spec: # Run two copies of the Pod replicas: 2 # Perform rolling updates, starting containers before stopping the old ones strategy: type: RollingUpdate rollingUpdate: maxSurge: 1 maxUnavailable: 0 selector: matchLabels: # This is how the Deployment recognizes its Pods, has to match the labels # of the Pod template app: flask-clock template: metadata: labels: app: flask-clock spec: containers: # Here's our Flask container - name: flask-app # Put your own image here image: registry.hsrn.nyu.edu/hsrn-projects/flask-clock ports: # This is the port we'll expose to the internet eventually - name: web containerPort: 5000 resources: requests: cpu: 10m # Request very little CPU memory: 100Mi # Request that this memory be allocated to us limits: cpu: 100m # Throttle the container if using more CPU memory: 100Mi # Terminate the container if using more memory Create the Deployment on the cluster by running: You can see the Pods get created and eventually get in the Running state: $ kubectl get pod NAME READY STATUS RESTARTS AGE flask-clock-7f87997659-6b2hz 0/1 ContainerCreating 0 2s flask-clock-7f87997659-9ldrs 0/1 ContainerCreating 0 2s $ k get pod NAME READY STATUS RESTARTS AGE flask-clock-7f87997659-6b2hz 1/1 Running 0 1m23s flask-clock-7f87997659-9ldrs 1/1 Running 0 1m23s Create the Service A Service is how Kubernetes routes network connections to containers.",https://k8s-docs.hsrn.nyu.edu/flask-service
scraped_data/k8s-docs.hsrn.nyu.edu/flask-service.html,5,"We will create a Service that will allow HTTP access to our application. Kubernetes will automatically route connections to any of the available Pods, wherever they are in the cluster.",https://k8s-docs.hsrn.nyu.edu/flask-service
scraped_data/k8s-docs.hsrn.nyu.edu/flask-service.html,6,"Write this manifest to service.yml : apiVersion: v1 kind: Service metadata: name: flask-clock labels: app: flask-clock source: hsrn-tutorial spec: type: ClusterIP # This is the default, a virtual IP address will be allocated selector: # This is how the Service will find the Pods app: flask-clock ports: - name: web protocol: TCP port: 80 # The port exposed by the service targetPort: 5000 # The port or port name of the Pod Create the Service on the cluster by running: You can see the Service using: $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE flask-clock ClusterIP 10.0.238.29 <none> 80/TCP 2s $ kubectl describe svc flask-clock Name: flask-clock Labels: k8s-app=flask-clock source=hsrn-tutorial Selector: k8s-app=flask-clock Type: ClusterIP IP: 10.0.238.29 Port: web 80/TCP TargetPort: 5000/TCP Endpoints: 10.0.27.101:5000,10.0.52.247:5000 Other containers in your namespace can use the Service's name (flask-clock ) or IP (for me, 10.0.238.29 ) to access your application.",https://k8s-docs.hsrn.nyu.edu/flask-service
scraped_data/k8s-docs.hsrn.nyu.edu/flask-service.html,7,"You can also see that there are two endpoints, since the Deployment is set to replicas: 2 . You can access your application locally by forwarding a port from the cluster: You can now open http://localhost:5000/ in the browser. Kubectl will forward your connection to the Service, and you will be get an answered from one of the two containers running in the cluster. Create an Ingress with a subdomain We have exposed the application to other containers in the cluster, and to developers using Kubectl. By using an Ingress, we can make it available to users. An Ingress is a set of rules to route HTTP requests for a subdomain and path to specific Service(s). Using an Ingress, you can control our HAProxy load-balancer to make it proxy requests to your own containers.",https://k8s-docs.hsrn.nyu.edu/flask-service
scraped_data/k8s-docs.hsrn.nyu.edu/flask-service.html,8,"Write this manifest to ingress.yml : apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: flask-clock labels: app: flask-clock source: hsrn-tutorial annotations: # Use the HAProxy ingress controller (currently the only option) kubernetes.io/ingress.class: haproxy # Instruct HAProxy to redirect HTTP to HTTPS, with the 301 ""permanent"" code haproxy.org/ssl-redirect: ""true"" haproxy.org/ssl-redirect-code: ""301"" # Instruct HAProxy to provide the end-user's address in the 'X-Forwarded-For' header haproxy.org/forwarded-for: ""true"" spec: rules: # You can have multiple rules in one Ingress, or create multiple Ingresses - host: flask-clock.users.hsrn.nyu.edu # You are welcome to take advantage of our *.users.hsrn.nyu.edu domain, # or you can use your own.",https://k8s-docs.hsrn.nyu.edu/flask-service
scraped_data/k8s-docs.hsrn.nyu.edu/flask-service.html,9,"In that case, you might have to provide a # certificate to enable HTTPS http: paths: - path: / pathType: Prefix backend: service: name: flask-clock port: number: 80 Create the Ingress on the cluster by running: You can see the Ingress using: $ kubectl get ingress NAME CLASS HOSTS ADDRESS PORTS AGE flask-clock <none> flask-clock.users.hsrn.nyu.edu 80 2m32s Note that you might need to change the host to something more unique if other people are going through this tutorial. And of course you can now access your application at https://flask-clock.users.hsrn.nyu.edu/. Ingresses default to NYU-only For security reasons, Ingresses are only accessible from NYU networks. This includes the NYU VPN. This keeps our systems safe from access from unknown internet users. See the Ingress documentation for information on how to enable access from other networks or the public internet, optionally behind password authentication.",https://k8s-docs.hsrn.nyu.edu/flask-service
scraped_data/k8s-docs.hsrn.nyu.edu/flask-service.html,10,"Clean up You can delete all the objects you created in this tutorial by using the labels, like this:",https://k8s-docs.hsrn.nyu.edu/flask-service
scraped_data/k8s-docs.hsrn.nyu.edu/storage.html,0,"How to use persistent storage By default, Pods use exphemeral storage. If you delete the Pod, or it gets evicted for any reason (node failure, image update, application crash, ...) all the data written to disk will be lost. To avoid that, you can request a Persistent Volume and mount it into your containers. Persistent Volumes are provided by our Ceph cluster, a networked data storage system. The data you store on Ceph will be persisted across your Pods, even if you restart or recreate them. Requesting a Persistent Volume with a Persistent Volume Claim The way you create a volume is by creating a Persistent Volume Claim into Kubernetes. It describes the type of storage you want and the capacity you need.",https://k8s-docs.hsrn.nyu.edu/storage
scraped_data/k8s-docs.hsrn.nyu.edu/storage.html,1,"For example: apiVersion: v1 kind: PersistentVolumeClaim metadata: name: my-volume spec: storageClassName: csi-rbd-3-sc # Or remove this line to use the default accessModes: - ReadWriteOnce resources: requests: storage: 100Gi Create it and check its status: $ kubectl apply -f my-volume.yml persistentvolumeclaim/my-volume created $ kubectl get persistentvolumeclaim NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE my-volume Bound pvc-cc8b4d67-e9fc-4651-9a9e-f85304c3cbcd 100Gi RWO csi-rbd-3-sc 2s If the ""status"" is ""Bound"", then a volume was successfully allocated and bound to that claim. You can now mount it into a Pod. If the ""status"" stays ""Pending"", then no volume was bound to it. This can happen if you used the wrong storageClassName or accessModes , or if you requested too much capacity. Mounting a persistent volume in a Pod To use the PersistentVolumeClaim, you attach it to a Pod, and mount it in your desired location in the Pod's containers.",https://k8s-docs.hsrn.nyu.edu/storage
scraped_data/k8s-docs.hsrn.nyu.edu/storage.html,2,"You can also do this if you are creating a Deployment, Job, etc by putting it in the Pod template section of the manifest. For example, this is a Job with one container, with a persistent volume mount as /data : apiVersion: batch/v1 kind: Job metadata: name: my-job spec: template: spec: restartPolicy: Never volumes: # This section describes the Pod's volumes # Those volumes can be mounted by containers, below - name: persistent-data persistentVolumeClaim: claimName: my-volume containers: - name: experiment image: quay.io/researcher/important-experiment:v1 volumeMounts: # This section indicates where to mount the Pod's volumes - name: persistent-data mountPath: /data Available storage class names Solid-state drive storage is faster but less plentiful. If you need more storage please contact us.",https://k8s-docs.hsrn.nyu.edu/storage
scraped_data/k8s-docs.hsrn.nyu.edu/status.html,0,Skip to content HSRN Kubernetes Cluster Cluster status Initializing search GitLab HSRN Kubernetes Cluster GitLab Introduction Get started How To How To Expose a web application to the internet Expose a container's port to the network Use persistent storage Use GPUs Send emails on job completion View and query logs Select a specific physical location Tutorials Tutorials Build and deploy a Flask application Run a batch job Our policies Cluster status Cluster status Table of contents Compute Storage Table of contents Compute Storage Cluster status Compute Storage,https://k8s-docs.hsrn.nyu.edu/status
scraped_data/k8s-docs.hsrn.nyu.edu/index.html,0,"HSRN Kubernetes Cluster Introduction This cluster is run by the High-Speed Research Network group (HSRN), part of High Performance Computing at New York University. It is available for teaching and research, currently in a pilot phase. It offers access to Kubernetes, an open-source container orchestration system that you can use to run experiments or applications on the cluster as containers. Use of this system relies on you understanding Kubernetes and how to use it. There is extensive introductory documentation that can help you get started if you are new to it. Note that Kubernetes can be harder to use than traditional HPC such as SLURM. You will have to provide detailed configuration for your desired workloads, in YAML format. In particular the filesystem of a container is not persistent by default, if you don't explicitly mount a persistent volume you might lose data! So do read the documentation and try a few examples on the cluster if you are just starting out with Kubernetes.",https://k8s-docs.hsrn.nyu.edu/index
scraped_data/k8s-docs.hsrn.nyu.edu/index.html,1,"Where to get support Please email hsrn-support@nyu.edu with questions or issues. Hardware overview - Dell PowerEdge machines, 36 total - Distributed in 7 different NYU buildings - 724 cores - 11027 GB of RAM - 14 NVIDIA GPUs See the status page for current utilization.",https://k8s-docs.hsrn.nyu.edu/index
scraped_data/k8s-docs.hsrn.nyu.edu/gpu.html,0,"How to use GPUs If you need a GPU, you can request one by adding a resource limit for a number of nvidia.com/gpu , for example 1 (this is constrained by the number of GPUs available, and your quotas).",https://k8s-docs.hsrn.nyu.edu/gpu
scraped_data/k8s-docs.hsrn.nyu.edu/gpu.html,1,"apiVersion: v1 kind: Pod metadata: name: gpu-test spec: containers: - name: cuda-container image: nvcr.io/nvidia/cuda:9.0-devel resources: limits: nvidia.com/gpu: 1 # Request 1 NVIDIA GPU If you are using a Job, put the resource limit in the pod template: apiVersion: batch/v1 kind: Job metadata: name: gpu-test spec: template: spec: restartPolicy: Never containers: - name: cuda-container image: nvcr.io/nvidia/cuda:9.0-devel resources: limits: nvidia.com/gpu: 1 # Request 1 NVIDIA GPU List of available GPUs hsrn-ed7a-370j NVIDIA A100 (40GB)NVIDIA A100 (40GB) hsrn-edbse-12wvpl NVIDIA Quadro RTX 8000 (48 GB) hsrn-ed2a-60fifthave NVIDIA Quadro RTX 8000 (48 GB) hsrn-ed2n-rcdc NVIDIA Quadro RTX 8000 (48 GB)NVIDIA Quadro RTX 8000 (48 GB) hsrn-ed10d-7e12 NVIDIA A100 (80GB)NVIDIA A100 (80GB) hsrn-ed2d-wwh NVIDIA A100 (40GB)NVIDIA A100 (40GB) hsrn-ed5a-meyer NVIDIA A100 (80GB)NVIDIA A100 (80GB)",https://k8s-docs.hsrn.nyu.edu/gpu
scraped_data/k8s-docs.hsrn.nyu.edu/get-started.html,0,"Get started Install the client To log into the Kubernetes cluster, you need to download the Kubectl client. If you want to build new container images, you should also install Docker. Go to https://config.hsrn.nyu.edu/ and click on ""get your config"". You will be asked to log in using one of a long list of provider. Please select ""New York University"" if you have an NYU netID. After you log in, you will be shown a YAML file. Put that file in .kube/config in your home directory (that's a file called config , with no file extension, in a directory called .kube . You can create the .kube directory if it doesn't exist.) Alternatively, you can put the configuration file somewhere else and either: - set the KUBECONFIG environment variable to its location; or - use the --kubeconfig option every time you runkubectl , for examplekubectl --kubeconfig /Users/remi/kubeconfig.nyu.txt get pod Warning The configuration file contains the secret key that allows you to access the cluster.",https://k8s-docs.hsrn.nyu.edu/get-started
scraped_data/k8s-docs.hsrn.nyu.edu/get-started.html,1,"Do not share that file with anybody else. Get access After you log in for the first time, an HSRN staff member will have to add you to a Kubernetes namespace. Email hsrn-support@nyu.edu with your netID and the name you want for your namespace. We will process your request and send a confirmation when the setup is complete. Warning Please get your configuration file as outlined above before emailing us. We will not be able to give you access until you have signed in at least once. Once you have access and you have downloaded your configuration file (see previous section), you can select your namespace by entering the following (replacing MY-NAMESPACE with your actual namespace): Check your access by doing: Next steps Remember that containers are not meant to be long-lived and may be restarted at any time. If you need a workload to run to completion, wrap it in a Batch Job and Kubernetes will automatically restart it if it fails (possibly on a different machine).",https://k8s-docs.hsrn.nyu.edu/get-started
scraped_data/k8s-docs.hsrn.nyu.edu/get-started.html,2,"Make sure your workload can restart where it left off if possible. The Kubernetes documentation has more details about the core concepts, as well as many tutorials. You can also find tutorials here from the sidebar on the left.",https://k8s-docs.hsrn.nyu.edu/get-started
scraped_data/k8s-docs.hsrn.nyu.edu/batch.html,0,"Run a batch job Introduction This tutorial will take you through running a computation on the cluster as a batch job. It uses a script written in Python, but many steps are not specific to Python. The goal is to find the solution of an integer equation. To go through this tutorial, you will need access to the Kubernetes cluster; see Get Started. See also How to send emails on job completion.",https://k8s-docs.hsrn.nyu.edu/batch
scraped_data/k8s-docs.hsrn.nyu.edu/batch.html,1,"Write the code This is the Python code we'll use, please put it in a file solver.py : import sys def f(value): value += 1610142364 for k in range(5): k = value // 127773 value = 16807 * (value - k * 127773) - k * 2836 if value <= 0: value = value + 2147483647 return value def main(lower, higher): for i in range(lower, higher): if i % 5000000 == 0: print(""%d..."" % i) if f(i) == 45: print(""Found solution: %d"" % i) return print(""No solution in [%d, %d)"" % (lower, higher)) if __name__ == '__main__': main(int(sys.argv[1], 10), int(sys.argv[2], 10)) As you can see, it takes as arguments the two endpoints of the range to search, and prints the solution if it finds it. Submit it as a job Because this job only requires a single short file, we will use a ConfigMap to send it into the cluster. ConfigMap are commonly used to store configuration values for other workloads. If we had more code, we would build a new Docker container image from our code.",https://k8s-docs.hsrn.nyu.edu/batch
scraped_data/k8s-docs.hsrn.nyu.edu/batch.html,2,You can see an example of that in the Flask application tutorial.,https://k8s-docs.hsrn.nyu.edu/batch
scraped_data/k8s-docs.hsrn.nyu.edu/batch.html,3,"You can create a ConfigMap named solver that contains our script using this command: You can see that it has been created: Now write this Job definition to job.yml : apiVersion: batch/v1 kind: Job metadata: name: solver labels: app: solver source: hsrn-tutorial spec: template: spec: restartPolicy: Never containers: - name: python image: python:3.10 args: [""python"", ""-u"", ""/app/solver.py"", ""0"", ""100000000""] volumeMounts: - name: script mountPath: /app resources: requests: cpu: 1 # Request one CPU (code is not multi-threaded) memory: 5Mi # Request that this memory be allocated to us limits: cpu: 2 # Throttle the container if using more CPU memory: 100Mi # Terminate the container if using more memory volumes: - name: script configMap: name: solver And submit it with Kubectl: Monitoring your Job You can see the Job and the Pod that has been created for it: $ kubectl get job NAME COMPLETIONS DURATION AGE solver 0/1 50s 50s $ kubectl get pod NAME READY STATUS RESTARTS AGE solver--1-rshnr 1/1 Running 0 51s If there was a failure, or if you simply delete the Pod, a new Pod will be created and start over: $ kubectl delete pod solver--1-rshnr pod ""solver--1-rshnr"" deleted $ kubectl get pod NAME READY STATUS RESTARTS AGE solver--1-rshnr 1/1 Terminating 0 59s solver--1-vkzs7 0/1 ContainerCreating 0 2s You can see the output from the Pod (once it starts) using: $ kubectl logs -f job/solver 0...",https://k8s-docs.hsrn.nyu.edu/batch
scraped_data/k8s-docs.hsrn.nyu.edu/batch.html,4,"1000000... 2000000... 3000000... 4000000... 5000000... 6000000... 7000000... And after a few minutes the Job completes: Parallelism It is possible to run a Job that consists of multiple tasks. Each task will be run as a separate Pod, either in turn or at the same time. There are multiple configurations that varies based on when the Kubernetes Job controller should consider the Job completed. You can refer to the official documentation for a complete list of options. We are going to accelerate our search by running 10 separate Pods, which will each search in a separate range.",https://k8s-docs.hsrn.nyu.edu/batch
scraped_data/k8s-docs.hsrn.nyu.edu/batch.html,5,"We will make the following changes to our Job definition: - Set completions to 10 - Set completionMode toIndexed , which will give each Pod an index from 0 to 9 as theJOB_COMPLETION_INDEX environment variable - Set parallelism to 4, which will allow Kubernetes to run 4 of the 10 Pods at a time - Change the container's command to search in the correct range based on the index in the Job, computed using bash Create the new manifest as job-parallel.yml : apiVersion: batch/v1 kind: Job metadata: name: solver-parallel labels: app: solver source: hsrn-tutorial spec: completions: 10 parallelism: 4 completionMode: Indexed template: spec: restartPolicy: Never containers: - name: python image: python:3.10 args: - bash - -c - ""python -u /app/solver.py $(expr $JOB_COMPLETION_INDEX \\* 10000000) $(expr \\( $JOB_COMPLETION_INDEX + 1 \\) \\* 10000000)"" volumeMounts: - name: script mountPath: /app resources: # Resource request and limits apply to each container, # not to the whole Job requests: cpu: 1 memory: 5Mi limits: cpu: 2 memory: 100Mi volumes: - name: script configMap: name: solver Create the new Job and watch the Pods get created, four by four: $ kubectl apply -f job-parallel.yml job.batch/solver-parallel configured $ kubectl get pod --watch NAME READY STATUS RESTARTS AGE solver-parallel-0-gb75c 0/1 ContainerCreating 0 2s solver-parallel-1-2rr8t 0/1 ContainerCreating 0 2s solver-parallel-2-f6dt8 0/1 ContainerCreating 0 2s solver-parallel-3-789vq 0/1 ContainerCreating 0 2s solver-parallel-0-gb75c 1/1 Running 0 5s solver-parallel-1-2rr8t 1/1 Running 0 5s solver-parallel-2-f6dt8 1/1 Running 0 5s solver-parallel-3-789vq 1/1 Running 0 5s solver-parallel-0-gb75c 0/1 Completed 0 18s solver-parallel-3-789vq 0/1 Completed 0 18s ...",https://k8s-docs.hsrn.nyu.edu/batch
scraped_data/k8s-docs.hsrn.nyu.edu/batch.html,6,"After a few seconds, all Pods are completed, and the Job reports this too: You can get the logs of all the Pods using a label selector. The Pods will not be in order, but you will be able to see the solution: $ kubectl logs -l job-name=solver-parallel 10000000... 15000000... No solution in [10000000, 20000000) 70000000... 75000000... No solution in [70000000, 80000000) 80000000... 85000000... No solution in [80000000, 90000000) 40000000... 45000000... No solution in [40000000, 50000000) 50000000... 55000000... No solution in [50000000, 60000000) 60000000... Found solution: 64782617 90000000... 95000000... No solution in [90000000, 100000000) 0... 5000000... No solution in [0, 10000000) 20000000... 25000000... No solution in [20000000, 30000000) 30000000... 35000000... No solution in [30000000, 40000000) Clean up You can delete all the Jobs you created in this tutorial by using the labels, like this: Also delete the ConfigMap:",https://k8s-docs.hsrn.nyu.edu/batch
scraped_data/k8s-docs.hsrn.nyu.edu/ingress.html,0,"How to expose an application to the internet Once you have an application with a Service, you can make it available from the internet using an Ingress. Creating an Ingress object will automatically configure our load-balancer to send requests to your application. For non-HTTP use cases, use a NodePort Use this method to expose web applications via a domain name. If you want direct access to a containers from inside the NYU network, use a NodePort instead. Load balancer information Our load balancer uses the IP 216.165.12.42 . The subdomains *.users.hsrn.nyu.edu will resolve to that IP. We also have a certificate which covers all those subdomains, so your application can benefit from HTTPS without further configuration. Ingress defaults to NYU-only access For security reasons, an Ingress only allows access to NYU networks. This includes the NYU VPN. See how to allow public access if you are certain you need it.",https://k8s-docs.hsrn.nyu.edu/ingress
scraped_data/k8s-docs.hsrn.nyu.edu/ingress.html,1,"Using our load balancer with our domain For example, to expose a Service called my-application with port 8000 at my-application.users.hsrn.nyu.edu , use the following Ingress: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: my-application-at-hsrn annotations: kubernetes.io/ingress.class: haproxy # The following 2 lines redirect HTTP traffic to HTTPS for you haproxy.org/ssl-redirect: ""true"" haproxy.org/ssl-redirect-code: ""301"" # The following line record the user's IP address in the 'X-Forwarded-For' header haproxy.org/forwarded-for: ""true"" spec: rules: - host: my-application.users.hsrn.nyu.edu http: paths: - path: / pathType: Prefix backend: service: # This is the name and port of your Service name: my-application port: number: 8000 Using our load balancer with your own domain If you want to use another domain name, rather than users.hsrn.nyu.edu , you will have to point it at our IP address: 216.165.12.42 . This is done using an A record .",https://k8s-docs.hsrn.nyu.edu/ingress
scraped_data/k8s-docs.hsrn.nyu.edu/ingress.html,2,"Depending on the registrar from whom you bought your domain, the procedure will be different, but they should all support this operation.",https://k8s-docs.hsrn.nyu.edu/ingress
scraped_data/k8s-docs.hsrn.nyu.edu/ingress.html,3,"For example, to expose a Service called my-application with port 8000 at my-application.example.org , use the following Ingress: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: my-application-own-domain annotations: kubernetes.io/ingress.class: haproxy spec: rules: - host: my-application.example.org http: paths: - path: / pathType: Prefix backend: service: # This is the name and port of your Service name: my-application port: number: 8000 If you have a TLS certificate for your domain, you can upload it to the cluster as a Secret: You can then use it in your Ingress to enable HTTPS: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: my-application-own-domain annotations: kubernetes.io/ingress.class: haproxy # The following 2 lines redirect HTTP traffic to HTTPS for you haproxy.org/ssl-redirect: ""true"" haproxy.org/ssl-redirect-code: ""301"" # The following line record the user's IP address in the 'X-Forwarded-For' header haproxy.org/forwarded-for: ""true"" spec: rules: - host: my-application.example.org http: paths: - path: / pathType: Prefix backend: service: # This is the name and port of your Service name: my-application port: number: 8000 tls: - hosts: - my-application.example.org secretName: my-application.example.org Access control By default, ingresses allow access from NYU networks.",https://k8s-docs.hsrn.nyu.edu/ingress
scraped_data/k8s-docs.hsrn.nyu.edu/ingress.html,4,Password authentication You can require a password to access your ingress using the following annotations: metadata: annotations: ... # Use password authentication haproxy.org/auth-type: basic-auth haproxy.org/auth-secret: my-application-ingress-password Create the corresponding secret with the following manifest: apiVersion: v1 kind: Secret metadata: name: my-application-ingress-password stringData: username: $2y$05$NdhtDwim4PFy0/lBVU2dBOkNmD/.IKcbacQ4ECy3FYXVnX1IRY.Ka anotheruser: $2y$05$Duchp5Lwmwy0BJU.0xsZ7eZTRPvc5wVxFmwKcQeqt6LTXLyzy84mq You can generate the hashed password using the htpasswd tool: $ htpasswd -n -B username New password: Re-type new password: username:$2y$05$NdhtDwim4PFy0/lBVU2dBOkNmD/.IKcbacQ4ECy3FYXVnX1IRY.Ka Note the space after : YAML syntax requires you to put a space after the colon : in the secret. The htpasswd command outputs a colon and no space. Don't forget to add it.,https://k8s-docs.hsrn.nyu.edu/ingress
scraped_data/k8s-docs.hsrn.nyu.edu/ingress.html,5,"Allowing access from the internet By default, an Ingress only allows access from NYU networks. You can allow access from the whole internet using the following annotation. Do NOT let unknown users access sensitive data or services With great power comes great responsibility. You have been provided access with a way to run services in a self-service manner. You will lose access and be held responsible if you let untrusted users into our systems. For example, make sure not to enable unknown users execute commands or run code on our cluster. This includes running JupyterHub or Notebook, RStudio, remote desktops, proxy servers, etc. Abide by the Policy on Responsible Use of NYU Computers and Data. Consider keeping services accessible to NYU users only (this will automatically include users on the NYU VPN) or locked behind a strong password.",https://k8s-docs.hsrn.nyu.edu/ingress
scraped_data/k8s-docs.hsrn.nyu.edu/ingress.html,6,"# Only enable for safe sites that # don't allow running commands and don't disclose sensitive data hpc.nyu.edu/access: ""public"" You can allow specific IP addresses and prefixes using this annotation: Please use public internet access responsibly. In the future, we may need to block this feature if security is not taken seriously by everyone. Remember, it is better to take 2 minutes before your deadline to set up a password or IP whitelist, than have your site come down during your demo because security caught you.",https://k8s-docs.hsrn.nyu.edu/ingress
scraped_data/k8s-docs.hsrn.nyu.edu/nodeport.html,0,"How to connect to a container's port from the NYU network By default, a Service is only reachable from other workloads inside the cluster. If you want to reach it from somewhere else on the NYU network, you can expose it on the cluster's nodes via a NodePort. For web applications, use an Ingress Use this method to expose a raw TCP or UDP port to the NYU network. If you want to expose a web application to the internet, using a domain name, and a valid HTTPS certificate, use an Ingress instead. Creating a NodePort service All you have to do is set type: NodePort in your Service definition.",https://k8s-docs.hsrn.nyu.edu/nodeport
scraped_data/k8s-docs.hsrn.nyu.edu/nodeport.html,1,"For example: apiVersion: v1 kind: Service metadata: name: myapp-nodeport spec: type: NodePort # The default is ClusterIP, a virtual IP address that is only reachable inside the cluster selector: app: myapp ports: - name: input protocol: TCP port: 3000 # The port number or name of the Pod # nodePort: 30007 # Optional: pick an unused port in the range 30000-32767 The Service above would give access to port 3000 of Pods labelled app=myapp . If you don't pick a port explicitly, one will be picked for you automatically. You can see it by using kubectl get svc : $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE myapp-nodeport NodePort 10.0.171.182 <none> 3000:30403/TCP 10s In this case, you can see the port number 30403 was allocated. You can reach this service on the IP address of any node of the cluster, for example 10.32.250.15:30403 . Use kubectl get node -o wide to see the list of nodes and their addresses.",https://k8s-docs.hsrn.nyu.edu/nodeport
scraped_data/k8s-docs.hsrn.nyu.edu/job-email.html,0,"How to send emails on job completion You can set your Job to notify you when they complete, fail, or restart. Email notifications are available for NYU addresses only. All you need to do is add a label to enable notifications, and an annotation to list the recipients, for example: apiVersion: batch/v1 kind: Job metadata: labels: k8s-emailer.hpc.nyu.edu/mode: ""complete"" # ""all"": email for all status changes (succeeds, fails, restarts) # ""complete"": email for failure or success # ""failure"": email for failure (not success) annotations: k8s-emailer.hpc.nyu.edu/addresses: ""alice@example.org, bob@example.org"" # ... spec: # ...",https://k8s-docs.hsrn.nyu.edu/job-email
scraped_data/k8s-docs.hsrn.nyu.edu/location.html,0,"How to select a specific physical location Our clusters extends to multiple locations in NYU. If you want, you can choose to have your workloads run in specific buildings by adding a nodeSelector to your workloads with the label topology.kubernetes.io/zone .",https://k8s-docs.hsrn.nyu.edu/location
scraped_data/k8s-docs.hsrn.nyu.edu/location.html,1,"For example: apiVersion: v1 kind: Pod metadata: name: edge-compute spec: containers: - name: python:3.10 nodeSelector: topology.kubernetes.io/zone: ""wwh"" Another option is nodeAffinity , which is more verbose but a little more powerful: apiVersion: v1 kind: Pod metadata: name: edge-compute spec: containers: - name: python:3.10 affinity: nodeAffinity: # Prefer running in 60fifthave preferredDuringSchedulingIgnoredDuringExecution - weight: 1 preference: matchExpressions: - key: topology.kubernetes.io/zone operator: In values: - ""60fifthave"" # Only run in either 60fifthave or 7e12 requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: topology.kubernetes.io/zone operator: In values: - ""60fifthave"" - ""7e12"" The zones available for your use are: See also Assigning Pods to Nodes in the official Kubernetes documentation. Make sure to use quotes around 7e12 If you put 7e12 in YAML, it will be recognized as the number 7000000000000.0 .",https://k8s-docs.hsrn.nyu.edu/location
scraped_data/k8s-docs.hsrn.nyu.edu/location.html,2,"You need to put quotes around it: ""7e12""",https://k8s-docs.hsrn.nyu.edu/location
scraped_data/k8s-docs.hsrn.nyu.edu/logs.html,0,"How to view and query logs The kubectl logs command allows you to see logs. It is useful during development, but it is limited to a single container at a time, and Pods that still currently exist. If you want to view older logs or perform query over them, you can use Grafana Loki. Head over to https://logs.hsrn.nyu.edu/ and click ""sign in with OAuth"". See the Loki documentation for help formulating queries.",https://k8s-docs.hsrn.nyu.edu/logs
scraped_data/k8s-docs.hsrn.nyu.edu/policies.html,0,"Our policies We don't have strict policies yet during our pilot phase, however please understand that the resources are shared between everybody. - Abide by the Policy on Responsible Use of NYU Computers and Data - Don't set incorrect resource requests: the system will assume that you need the requested resources and will not put them towards another user's workload. Try to set a request as close as possible to your average need. - Don't rely on containers running forever: though we will try to keep the cluster stable, individual nodes will go down for maintenance periodically. At that time your pods will be ""evicted"". Using Deployments or Jobs instead of Pods is recommended, in that case new pods will be automatically started to replace the lost ones. Backups Persistent volumes have daily backups which are kept for 30 days. Contact us if you need to recover data.",https://k8s-docs.hsrn.nyu.edu/policies
